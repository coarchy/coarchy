<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-3.xsd">
    <service verb="invite" noun="NewUser">
        <in-parameters>
            <parameter name="partyId" required="true"/>
            <parameter name="emailAddress" required="true"/>
            <parameter name="firstName" required="true"/>
            <parameter name="lastName" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="newUserId"/>
            <parameter name="newPartyId"/>
        </out-parameters>
        <actions>
            <service-call name="coarchy.CoarchyServices.invite#User" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="invite" noun="User">
        <in-parameters>
            <parameter name="partyId" required="true"/>
            <parameter name="emailAddress" required="true"/>
            <parameter name="firstName"/>
            <parameter name="lastName"/>
        </in-parameters>
        <out-parameters>
            <parameter name="newUserId"/>
            <parameter name="newPartyId"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.party.PartyDetail" value-field="organization" auto-field-map="[partyId:partyId]"/>
            <if condition="!organization || !organization.ownerPartyId"><return/></if>
            <if condition="organization.ownerPartyId == ec.user.userAccount.partyId">
                <entity-find entity-name="moqui.security.UserAccount" list="existingUaList">
                    <econdition field-name="emailAddress" ignore-case="true"/></entity-find>
                <if condition="!existingUaList"><then>
                    <service-call name="mantle.party.PartyServices.create#Account" out-map="newUser"
                        in-map="[emailAddress:emailAddress,firstName:firstName?:'Coarchy',lastName:lastName?:'Customer',username:emailAddress]"/>
                    <service-call name="create#mantle.party.PartyRole" in-map="[partyId:newUser.partyId,roleTypeId:'Customer']"/>
                    <service-call name="create#moqui.security.UserGroupMember" in-map="[userGroupId:'COARCHY_USERS',
                        userId:newUser.userId, fromDate:ec.user.nowTimestamp]"/>
                    <!-- Sales Journey Prospect for invited user -->
                    <service-call name="mantle.party.PartyServices.set#PartyClassification" in-map="[partyId:newUser.partyId,partyClassificationId:'Prospect']"/>
                </then><else>
                    <set field="newUser" from="existingUaList?.getFirst()"/>
                </else></if>
                <set field="newPartyId" from="newUser.partyId"/>
                <set field="newUserId" from="newUser.userId"/>

                <service-call name="create#mantle.party.PartyRelationship" in-map="[relationshipTypeEnumId:'PrtMember',
                    fromPartyId:newUser.partyId,toRoleTypeId:'OrgInternal',toPartyId:partyId,fromDate:ec.user.nowTimestamp]"/>
                <service-call name="org.moqui.impl.UserServices.set#Preference" in-map="[preferenceKey:'ACTIVE_ORGANIZATION',preferenceValue:partyId]"/>

                <set field="baseLinkUrl" from="!'production'.equals(System.getProperty('instance_purpose')) ? 'http://localhost:8080' : 'https://coarchy.com'"/>
                <if condition="!existingUaList"><then>
                    <entity-find-one entity-name="moqui.security.UserAccount" value-field="userAccount" auto-field-map="[userId:newUser.userId]" for-update="true"/>
                    <!-- reset the password to a random value -->
                    <set field="resetPassword" from="getRandomString(12)"/>
                    <set field="passwordNode" from="ec.ecfi.confXmlRoot.first('user-facade').first('password')"/>
                    <set field="userAccount.resetPassword" from="ec.ecfi.getSimpleHash(resetPassword, userAccount.passwordSalt, userAccount.passwordHashType, 'Y'.equals(userAccount.passwordBase64))"/>
                    <set field="userAccount.requirePasswordChange" from="(passwordNode.attribute('email-require-change') == 'true') ? 'Y' : 'N'"/>
                    <entity-update value-field="userAccount"/>

                    <service-call name="coarchy.CoarchyServices.send#ContactListEmail" in-map="[
                        contactListId:'CoarchyInvitation',emailTemplateId:'USER_INVITE_RESET_PASSWORD',
                        partyId:newPartyId,preferredContactMechId:newUser.emailContactMechId,toAddresses:emailAddress,
                        bodyParameters:[linkUrl:baseLinkUrl+'/ChangePassword?username='+emailAddress+'&amp;oldPassword='+resetPassword,
                        title:'You\'re invited to join the '+organization.organizationName+' Organization',baseLinkUrl:baseLinkUrl]]" out-map="context"/>
                </then><else>
                    <service-call name="coarchy.CoarchyServices.send#ContactListEmail" in-map="[
                        contactListId:'CoarchyInvitation',emailTemplateId:'USER_INVITE',
                        partyId:newPartyId,preferredContactMechId:null,toAddresses:emailAddress,
                        bodyParameters:[linkUrl:baseLinkUrl+'/Login?username='+existingUaList.getFirst()?.username?:emailAddress,
                        title:'You\'re invited to join the '+organization.organizationName+' Organization',baseLinkUrl:baseLinkUrl]]" out-map="context"/>
                </else></if>
                
                <else><return type="danger" error="true" message="Not allowed"/></else>
            </if>
        </actions>
    </service>
    <service verb="send" noun="ContactListEmail">
        <in-parameters>
            <parameter name="contactListId" required="true"/>
            <parameter name="emailTemplateId" required="true"/>
            <parameter name="partyId" required="true"/>
            <parameter name="bodyParameters" required="true" type="Map"/>
            
            <parameter name="preferredContactMechId"/>
            <parameter name="toAddresses"/>

            <parameter name="emailTypeEnumId" required="true" default-value="CONT_EMAIL_TEMPLATE"/>
        </in-parameters>
        <out-parameters>
            <parameter name="sentEmail"/>
        </out-parameters>
        <actions>
            <set field="sentEmail" from="false"/>
            <entity-find-one entity-name="mantle.marketing.contact.ContactList" value-field="invitationContact" auto-field-map="[contactListId:contactListId]"/>
            <if condition="!invitationContact">
                <log level="info" message="No ContactList found with contactListId of ${contactListId}"/>
                <message error="true" type="danger" public="true">Cannot send invitation email, please contact support for help</message>
            </if>
            <entity-find entity-name="mantle.marketing.contact.ContactListEmail" list="invitationContactListEmailList" limit="1">
                <econdition field-name="emailTemplateId"/>
                <econdition field-name="emailTypeEnumId"/>
                <date-filter/>
                <order-by field-name="-fromDate"/>
            </entity-find>
            <set field="invitationContactListEmail" from="invitationContactListEmailList?.getFirst()"/>
            <if condition="!invitationContactListEmail">
                <log level="info" message="No ContactListEmail found for emailTemplateId ${emailTemplateId} and emailTypeEnumId ${emailTypeEnumId}"/>
                <message error="true" type="danger" public="true">Cannot send invitation email, please contact support for help</message>
            </if>
            <entity-find entity-name="mantle.marketing.contact.ContactListParty" list="inviteContactListPartyList" limit="1" for-update="true">
                <econdition field-name="contactListId"/>
                <econdition field-name="partyId"/>
                <date-filter/>
                <order-by field-name="-fromDate"/>
            </entity-find>
            <set field="inviteContactListParty" from="inviteContactListPartyList?.getFirst()"/>
            <if condition="!preferredContactMechId">
                <entity-find entity-name="mantle.party.contact.PartyContactMech" list="partyContactMechList" limit="1">
                    <econdition field-name="partyId"/>
                    <econdition field-name="contactMechPurposeId" value="EmailPrimary"/>
                    <date-filter/>
                    <order-by field-name="-fromDate"/>
                </entity-find>
                <set field="preferredContactMechId" from="partyContactMechList?.getFirst()?.contactMechId"/>
            </if>
            <if condition="!inviteContactListParty"><then>
                <service-call name="create#mantle.marketing.contact.ContactListParty" in-map="[
                            contactListId:contactListId,partyId:partyId,statusId:'CLPT_IN_USE',
                            preferredContactMechId:preferredContactMechId,optInVerifyCode:getRandomString(63)]" out-map="inviteContactListPartyOut"/>
                <entity-find-one entity-name="mantle.marketing.contact.ContactListParty" value-field="inviteContactListParty"
                        auto-field-map="[contactListId:contactListId,partyId:partyId,fromDate:inviteContactListPartyOut.fromDate]"/>
            </then><else-if condition="!inviteContactListParty.optInVerifyCode">
                <set field="inviteContactListParty.optInVerifyCode" from="getRandomString(63)"/>
                <entity-update value-field="inviteContactListParty"/>
            </else-if></if>

            <if condition="inviteContactListParty.statusId != 'CLPT_IN_USE'"><then>
                <log level="info" message="Not sending invitation email because not in 'In Use' status"/>
                <message type="warning" public="true">Not sending email. User is unsubscribed from Invitation emails</message>
            </then><else>
                <service-call name="org.moqui.impl.EmailServices.send#EmailTemplate" in-map="[
                    emailTemplateId:emailTemplateId,toAddresses:toAddresses,bodyParameters:bodyParameters+[
                    currentYear:ec.user.nowTimestamp.format('yyyy'),contactListName:invitationContact.contactListName,
                    unsubscribeLink:bodyParameters.baseLinkUrl+invitationContact.optOutScreen+'?optInVerifyCode='+inviteContactListParty.optInVerifyCode]]"
                    out-map="context"/>
                <if condition="emailMessageId">
                    <set field="sentEmail" from="true"/>
                </if>

                <!-- TODO: Review approach -->
                <service-call name="mantle.party.CommunicationServices.create#Message" in-map="[
                    communicationEventTypeId:'Email',contactMechTypeEnumId:'CmtEmailAddress',statusId:'CeSent',
                    toContactMechId:preferredContactMechId,toPartyId:partyId,emailMessageId:emailMessageId,contactListId:contactListId]"
                    out-map="communicationEventOut"/>
                <service-call name="create#mantle.marketing.contact.ContactListCommStatus" in-map="[
                    contactListId:contactListId,communicationEventId:communicationEventOut.communicationEventId,
                    contactMechId:preferredContactMechId,partyId:partyId]"/>
            </else></if>
        </actions>
    </service>

    <service verb="create" noun="ProcessStory">
        <in-parameters>
            <parameter name="name" required="true"/>
            <parameter name="organizationId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="processStoryId"/>
        </out-parameters>
        <actions>
            <set field="name" from="name?.trim()"/>
            <entity-find entity-name="coarchy.ProcessStory" list="processStoryList" limit="20">
                <econdition field-name="name" ignore-case="true"/>
                <order-by field-name="^name"/>
            </entity-find>
            <if condition="processStoryList?.size() &gt; 0"><return type="danger" error="true" message="Process Story '${processStoryList?.getFirst()?.name}' already exists"/></if>

            <service-call name="create#coarchy.ProcessStory" in-map="[name:name,organizationId:organizationId]" out-map="context"/>
        </actions>
    </service>
    <service verb="update" noun="ProcessStory">
        <in-parameters>
            <parameter name="processStoryId" required="true"/>
            <parameter name="name" required="true"/>
            <parameter name="organizationId" required="true"/>
        </in-parameters>
        <actions>
            <set field="name" from="name?.trim()"/>
            <entity-find-one entity-name="coarchy.ProcessStory" value-field="processStory"/>
            <if condition="!processStory"><return type="danger" error="true" message="Process Story does not exist"/></if>

            <service-call name="update#coarchy.ProcessStory" in-map="[processStoryId:processStoryId,name:name]"/>
        </actions>
    </service>
    <service verb="enable" noun="ProcessStory">
        <description>Disable a process story (set disabled=Y, disabledDateTime=now)</description>
        <in-parameters><parameter name="processStoryId" required="true"/></in-parameters>
        <actions>
            <service-call name="update#coarchy.ProcessStory" in-map="[processStoryId:processStoryId, disabled:'N']"/>
        </actions>
    </service>
    <service verb="disable" noun="ProcessStory">
        <description>Disable a process story (set disabled=Y, disabledDateTime=now)</description>
        <in-parameters><parameter name="processStoryId" required="true"/></in-parameters>
        <actions>
            <service-call name="update#coarchy.ProcessStory" in-map="[processStoryId:processStoryId, disabled:'Y']"/>
        </actions>
    </service>
    <service verb="find" noun="ProcessStoryActivityList">
        <description>
            Find list of activities of process story
            For each activity that has a detailProcessStory, call this function with that processStoryId, return the list of activities
            Add the necessary fields for the activity and the detail process story name, and detail process story activity list
        </description>
        <in-parameters>
            <parameter name="processStoryId" required="true"/>
            <parameter name="showSubstories" required="true"/>
            <parameter name="organizationId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="processStoryActivityList"/>
        </out-parameters>
        <actions>
            <entity-find entity-name="coarchy.ProcessStoryActivityDetail" list="setupProcessStoryActivityList">
                <econdition field-name="processStoryId"/>
                <select-field field-name="activityId,condition,action,detailProcessStoryId,processStoryId"/>
                <order-by field-name="sequenceNum"/></entity-find>
            <set field="processStoryActivityList" from="[]"/>
            <iterate list="setupProcessStoryActivityList" entry="processStoryActivity">
                <entity-find entity-name="coarchy.ActivityActorDetail" list="activityActorList">
                    <econdition field-name="activityId" from="processStoryActivity.activityId"/>
                    <order-by field-name="name"/></entity-find>
                <set field="detailProcessStoryName" from="null"/>
                <set field="detailProcessStoryId" from="processStoryActivity.detailProcessStoryId"/>
                <set field="detailProcessStoryActivityList" from="[]"/>
                <if condition="processStoryActivity.detailProcessStoryId &amp;&amp; showSubstories!='N'">
                    <service-call name="coarchy.CoarchyServices.find#ProcessStoryActivityList" out-map="detail"
                            in-map="[processStoryId:processStoryActivity.detailProcessStoryId,showSubstories:showSubstories,
                            organizationId:organizationId]"/>
                    <entity-find-one entity-name="coarchy.ProcessStory" value-field="detailProcessStory" auto-field-map="[processStoryId:processStoryActivity.detailProcessStoryId]"/>
                    <set field="detailProcessStoryName" from="detailProcessStory.name"/>
                    <entity-find entity-name="coarchy.ProcessStoryActivityDetail" list="setupDetailProcessStoryActivityList">
                        <econdition field-name="processStoryId" from="processStoryActivity.detailProcessStoryId"/>
                        <select-field field-name="activityId,condition,action"/>
                        <order-by field-name="sequenceNum"/></entity-find>
                    <iterate list="setupDetailProcessStoryActivityList" entry="detailProcessStoryActivity">
                        <entity-find entity-name="coarchy.ActivityActorDetail" list="detailActivityActorList">
                            <econdition field-name="activityId" from="detailProcessStoryActivity.activityId"/>
                            <order-by field-name="name"/></entity-find>
                        <script>detailProcessStoryActivityList.add([sequenceNum:detailProcessStoryActivity.sequenceNum,condition:detailProcessStoryActivity.condition,actorNames:detailActivityActorList*.name,action:detailProcessStoryActivity.action])</script>
                    </iterate>
                </if>

                <script>processStoryActivityList.add([processStoryId:processStoryActivity.processStoryId,
                    sequenceNum:processStoryActivity.sequenceNum,condition:processStoryActivity.condition,
                    actorNames:activityActorList*.name,action:processStoryActivity.action,detailProcessStoryId:detailProcessStoryId,
                    detailProcessStoryName:detailProcessStoryName,detailProcessStoryActivityList:detail?.processStoryActivityList?.clone()])</script>
            </iterate>
        </actions>
    </service>

    <service verb="create" noun="Activity">
        <in-parameters>
            <parameter name="processStoryId" required="true"/>
            <parameter name="organizationId" required="true"/>
            <parameter name="condition"/>
            <parameter name="actorIdList" type="List"/>
            <parameter name="action"/>
            <parameter name="sequenceNum"/>
            <parameter name="implementationId"/>
            <parameter name="ignoreNoAction" default="false"/>
        </in-parameters>
        <out-parameters>
            <parameter name="activityId"/>
            <parameter name="processStoryActivityId"/>
            <parameter name="sequenceNum"/>
        </out-parameters>
        <actions>
            <if condition="!ignoreNoAction &amp;&amp; !action"><return type="warning" message="An action is needed for an activity"/></if>
            <service-call name="create#coarchy.Activity" in-map="[condition:condition?.trim(), action:action?.trim(), organizationId:organizationId, implementationId:implementationId]" out-map="newActivity"/>
            <set field="activityId" from="newActivity.activityId"/>

            <set field="newSequenceNum" from="sequenceNum"/>
            <if condition="!sequenceNum">
                <entity-find entity-name="coarchy.ProcessStoryActivity" limit="1" list="processStoryActivityList">
                    <econdition field-name="processStoryId"/>
                    <order-by field-name="-sequenceNum"/></entity-find>
                <set field="highestProcessStoryActivity" from="processStoryActivityList?.getFirst()"/>
                <set field="newSequenceNum" from="highestProcessStoryActivity?.sequenceNum != null ? highestProcessStoryActivity?.sequenceNum + 1 : 0"/>
            </if>
            <service-call name="create#coarchy.ProcessStoryActivity" in-map="[processStoryId:processStoryId,activityId:newActivity.activityId, sequenceNum:newSequenceNum, organizationId:organizationId]" out-map="newStoryActivity"/>
            <set field="processStoryActivityId" from="newStoryActivity.processStoryActivityId"/>
            <set field="sequenceNum" from="newStoryActivity.sequenceNum"/>

            <if condition="actorIdList?.size() != 0 &amp;&amp; actorIdList instanceof String">
                <then>
                    <service-call name="store#coarchy.ActivityActor" in-map="[activityId:newActivity.activityId, actorId:actorIdList, organizationId:organizationId]"/>
                </then>
                <else>
                    <iterate list="actorIdList" entry="actorId">
                        <service-call name="store#coarchy.ActivityActor" in-map="[activityId:newActivity.activityId, actorId:actorId, organizationId:organizationId]"/>
                    </iterate>
                </else>
            </if>
        </actions>
    </service>
    <service verb="update" noun="Activity">
        <in-parameters>
            <parameter name="activityId" required="true"/>
            <parameter name="condition"/>
            <parameter name="actorIdList" type="List"/>
            <parameter name="action" required="true"/>
            <parameter name="implementationId"/>
            <parameter name="organizationId" required="true"/>
        </in-parameters>
        <actions>
<!--            <log level="warn" message="update activity context.toString() ${context.toString()}"/>-->
            <service-call name="update#coarchy.Activity" in-map="[activityId:activityId,condition:condition.trim(),action:action.trim(),implementationId:implementationId]"/>
            <entity-find entity-name="coarchy.ActivityActorDetail" list="activityActorList">
                <econdition field-name="activityId"/>
                <order-by field-name="name"/></entity-find>
            <set field="actorIdServerList" from="activityActorList*.actorId"/>
            <if condition="actorIdServerList">
                <set field="actorIdDeleteList" from="actorIdServerList - actorIdList?:[]"/>
<!--                                    <log level="warn" message="actorIdDeleteList ${actorIdDeleteList}"/>-->
                <iterate list="actorIdDeleteList" entry="actorIdDelete">
                    <service-call name="delete#coarchy.ActivityActor" in-map="[activityId:activityId,actorId:actorIdDelete]"/>
                </iterate>
            </if>

            <set field="actorIdCreateList" from="actorIdList?:[] - actorIdDeleteList?:[]"/>
            <if condition="actorIdCreateList instanceof String">
                <then>
                    <service-call name="store#coarchy.ActivityActor" in-map="[activityId:activityId, actorId:actorIdCreateList, organizationId:organizationId]"/></then>
                <else>
                    <iterate list="actorIdCreateList" entry="actorIdCreate">
                        <service-call name="store#coarchy.ActivityActor" in-map="[activityId:activityId, actorId:actorIdCreate, organizationId:organizationId]"/>
                    </iterate>
                </else>
            </if>
        </actions>
    </service>

    <service verb="create" noun="ChecklistProcessStory">
        <in-parameters>
            <parameter name="processStoryId" required="true"/>
            <parameter name="name" required="true"/>
<!--            <parameter name="recurStartCron"/>-->
            <parameter name="organizationId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="rootWorkEffortId"/>
            <parameter name="taskWorkEffortIdList"/>
        </out-parameters>
        <actions><service-call name="coarchy.CoarchyServices.create#Checklist" in-map="context" out-map="context"/></actions>
    </service>

    <service verb="create" noun="Checklist">
        <in-parameters>
            <parameter name="processStoryId" required="true"/>
            <parameter name="name"/>
<!--            <parameter name="recurStartCron"/>-->
            <parameter name="organizationId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="rootWorkEffortId"/>
            <parameter name="taskWorkEffortIdList"/>
        </out-parameters>
        <actions>
            <set field="name" from="name?.trim()"/>
            <if condition="estimatedStartDate != null &amp;&amp; estimatedCompletionDate != null &amp;&amp;
                           estimatedCompletionDate &lt; estimatedStartDate">
                <return error="true" message="Project date range is not valid."/>
            </if>
            <entity-find entity-name="coarchy.ProcessStoryActivityDetail" list="processStoryActivityList">
                <econdition field-name="processStoryId"/>
                <select-field field-name="activityId,condition,action"/>
                <order-by field-name="sequenceNum"/></entity-find>
            <if condition="processStoryActivityList?.size() == 0">
                <return error="true" message="Need at least 1 activity to create a checklist"/></if>

            <if condition="!name">
                <entity-find-one entity-name="coarchy.ProcessStory" value-field="processStory" auto-field-map="[processStoryId:processStoryId]"/>
                <set field="name" from="processStory.name"/>
            </if>
<!--            <service-call name="create#mantle.work.effort.WorkEffort" in-map="[workEffortName:name,recurStartCron:recurStartCron,ownerPartyId:organizationId,workEffortTypeEnumId:'WetProject',actualStartDate:ec.user.nowTimestamp]" out-map="projectWorkEffort"/>-->
            <service-call name="create#mantle.work.effort.WorkEffort" out-map="projectWorkEffort" in-map="[workEffortName:name,ownerPartyId:organizationId,workEffortTypeEnumId:'WetChecklist',actualStartDate:ec.user.nowTimestamp]"/>
            <set field="rootWorkEffortId" from="projectWorkEffort.workEffortId"/>
            <set field="projectFromDate" from="ec.user.nowTimestamp"/>
            <service-call name="create#mantle.work.effort.WorkEffortParty"
                    in-map="[workEffortId:projectWorkEffort.workEffortId, partyId:ec.user.userAccount.partyId,
                            roleTypeId:'Owner', fromDate:projectFromDate]"/>

            <set field="taskWorkEffortIdList" from="[]"/>
            <iterate list="processStoryActivityList" entry="processStoryActivity">
                <if condition="processStoryActivity.action">
                    <entity-find entity-name="coarchy.ActivityActorDetail" list="activityActorList">
                        <econdition field-name="activityId" from="processStoryActivity.activityId"/>
                        <order-by field-name="name"/></entity-find>

                    <set field="processStoryActivity" from="processStoryActivity.getMap() + [actorNames:activityActorList*.name]"/>
                    <set field="taskName" from="ec.resource.template('component://coarchy/template/Activity.html.ftl', '.ftl')"/>
                    <if condition="activityActorList.size() == 0">
                        <service-call name="delete#mantle.work.effort.WorkEffortParty" in-map="[workEffortId:projectWorkEffort.workEffortId,
                            partyId:ec.user.userAccount.partyId,roleTypeId:'Owner', fromDate:projectFromDate]"/>
                        <iterate list="taskWorkEffortIdList" entry="taskWorkEffortId">
                            <service-call name="delete#mantle.work.effort.WorkEffort" in-map="[workEffortId:taskWorkEffortId]"/></iterate>
                        <service-call name="delete#mantle.work.effort.WorkEffort" in-map="[workEffortId:projectWorkEffort.workEffortId]"/>
                        <return error="true" message="Need at least 1 actor for Activity '${taskName}' in Process Story '${name}'"/></if>

                    <entity-find entity-name="coarchy.ActorPartyDetail" list="actorPartyList">
                        <econdition field-name="actorId" from="activityActorList*.actorId"/></entity-find>
                    <if condition="actorPartyList.size() == 0">
                        <service-call name="delete#mantle.work.effort.WorkEffortParty" in-map="[workEffortId:projectWorkEffort.workEffortId,
                            partyId:ec.user.userAccount.partyId,roleTypeId:'Owner', fromDate:projectFromDate]"/>
                        <iterate list="taskWorkEffortIdList" entry="taskWorkEffortId">
                            <service-call name="delete#mantle.work.effort.WorkEffort" in-map="[workEffortId:taskWorkEffortId]"/></iterate>
                        <service-call name="delete#mantle.work.effort.WorkEffort" in-map="[workEffortId:projectWorkEffort.workEffortId]"/>
                        <return error="true" message="Need at least 1 user for each of these actors '${activityActorList*.name.join(', ')}'"/></if>

                    <set field="seqName" value="Project_${projectWorkEffort.workEffortId}"/>
                    <set field="workEffortId" value="${projectWorkEffort.workEffortId}-${ec.entity.sequencedIdPrimary(seqName, null, 10)}"/>
                    <service-call name="create#mantle.work.effort.WorkEffort" out-map="taskWorkEffort" in-map="[
                        rootWorkEffortId:projectWorkEffort.workEffortId,workEffortId:workEffortId,workEffortName:taskName,
                        ownerPartyId:organizationId,workEffortTypeEnumId:'WetChecklistItem',activityId:processStoryActivity.activityId]"/>

                    <script>taskWorkEffortIdList.add(taskWorkEffort.workEffortId)</script>
                </if>
            </iterate>
        </actions>
    </service>
    <service verb="update" noun="Checklist">
        <in-parameters>
            <parameter name="workEffortId" required="true"/>
            <parameter name="workEffortName" required="true"/>
<!--            <parameter name="recurStartCron"/>-->
            <parameter name="organizationId" required="true"/>
        </in-parameters>
        <actions>
            <set field="workEffortName" from="workEffortName.trim()"/>
<!--            <service-call name="update#mantle.work.effort.WorkEffort" in-map="[workEffortId:workEffortId,workEffortName:workEffortName,recurStartCron:recurStartCron]"/>-->
            <service-call name="update#mantle.work.effort.WorkEffort" in-map="[workEffortId:workEffortId,workEffortName:workEffortName]"/>
        </actions>
    </service>
    <service verb="update" noun="Task">
        <in-parameters>
            <parameter name="workEffortId" required="true"/>
            <parameter name="assignedPartyIdList" type="List" required="true"/>
            <parameter name="resolutionEnumId"/>
            <parameter name="organizationId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.work.effort.WorkEffort" value-field="task" auto-field-map="[workEffortId:workEffortId]"/>
            <if condition="!task"><return type="warning" message="Task not found"/></if>

            <entity-find entity-name="mantle.work.effort.WorkEffortParty" list="workEffortPartyList">
                <date-filter/><econdition field-name="workEffortId"/>
                <econdition field-name="roleTypeId" value="Assignee"/>
                <order-by field-name="-fromDate"/>
            </entity-find>

            <set field="partyIdServerList" from="workEffortPartyList*.partyId"/>

            <if condition="partyIdServerList">
                <set field="partyIdDeleteList" from="partyIdServerList - assignedPartyIdList?:[]"/>

                <!--                                                    <log level="warn" message="partyIdDeleteList ${partyIdDeleteList}"/>-->
                <iterate list="partyIdDeleteList" entry="partyIdDelete">
<!--                    <log level="warn" message="workEffortPartyList.find{it.partyId==partyIdDelete}.fromDate ${workEffortPartyList.find{it.partyId==partyIdDelete}.fromDate}"/>-->
                    <service-call name="update#mantle.work.effort.WorkEffortParty" in-map="[workEffortId:workEffortId,partyId:partyIdDelete,roleTypeId:'Assignee',fromDate:workEffortPartyList.find{it.partyId==partyIdDelete}.fromDate,thruDate:ec.user.nowTimestamp]"/>
                </iterate>
            </if>
            <set field="baseLinkUrl" from="!'production'.equals(System.getProperty('instance_purpose')) ? 'http://localhost:8080' : 'https://coarchy.com'"/>

            <set field="partyIdCreateList" from="assignedPartyIdList?:[] - partyIdDeleteList?:[]"/>
            <!--                        <log level="warn" message="update#Actor context.toString() ${context.toString()}"/>-->
            <if condition="partyIdCreateList instanceof String">
                <then>
                    <service-call name="store#mantle.work.effort.WorkEffortParty" in-map="[workEffortId:workEffortId,partyId:partyIdCreateList,roleTypeId:'Assignee']"/>
                </then><else>
                <iterate list="partyIdCreateList" entry="partyIdCreate">
                    <service-call name="store#mantle.work.effort.WorkEffortParty" in-map="[workEffortId:workEffortId,partyId:partyIdCreate,roleTypeId:'Assignee',fromDate:workEffortPartyList.find{it.partyId==partyIdCreate}?.fromDate?:ec.user.nowTimestamp]"/>

                    <entity-find entity-name="mantle.work.effort.WorkEffort" list="taskList" limit="1">
                        <econdition field-name="rootWorkEffortId" from="task.rootWorkEffortId"/>
                        <econdition field-name="workEffortId" operator="less" from="workEffortId"/>
                        <order-by field-name="-workEffortId"/>
                    </entity-find>
<!--                    <log level="warn" message="workEffortId ${workEffortId} taskList ${taskList}"/>-->
                    <!-- Maybe send an assigned email, but on second thought it sounds annoying -->
<!--                    <if condition="ec.user.userAccount.partyId!=partyIdCreate &amp;&amp; (taskList.size() == 0 || !partyIdServerList.containsAll(assignedPartyIdList))">-->
                    <if condition="ec.user.userAccount.partyId!=partyIdCreate &amp;&amp; (taskList.size() == 0 || taskList.getFirst().resolutionEnumId!=null)">
                        <entity-find entity-name="moqui.security.UserAccount" list="userAccountList" limit="1">
                            <econdition field-name="partyId" from="partyIdCreate"/>
                            <select-field field-name="emailAddress"/>
                            <order-by field-name="-lastUpdatedStamp"/></entity-find>

                        <if condition="userAccountList?.getFirst()?.emailAddress == null"><then>
                            <message type="danger">Can't send email to notify about assignment</message>
                        </then><else>
                            <service-call name="coarchy.CoarchyServices.send#ContactListEmail" in-map="[
                                contactListId:'CoarchyTaskReminder',emailTemplateId:'TASK_ASSIGNED_NOTIFICATION',
                                partyId:partyIdCreate,toAddresses:userAccountList.getFirst().emailAddress,
                                bodyParameters:[linkUrl:baseLinkUrl+'/coapp/Checklist?checklistId='+task.rootWorkEffortId,baseLinkUrl:baseLinkUrl,
                                title:'You\'ve been assigned a task'+(ec.user.userAccount.userFullName?' by '+ec.user.userAccount.userFullName:'')]]" out-map="context"/>
                        </else></if>
                    </if>
                </iterate>
            </else></if>

<!--            <log level="warn" message="partyIdServerList.containsAll(assignedPartyIdList) ${partyIdServerList.containsAll(assignedPartyIdList)}"/>-->
<!--            <log level="warn" message="assignedPartyIdList ${assignedPartyIdList} partyIdServerList ${partyIdServerList}"/>-->

            <if condition="partyIdServerList.containsAll(assignedPartyIdList) &amp;&amp; workEffortPartyList.find{it.partyId == ec.user.userAccount.partyId} != null &gt; 0 &amp;&amp; resolutionEnumId">
                <if condition="resolutionEnumId">
                    <set field="actualCompletionDate" from="ec.user.nowTimestamp"/>
                    <service-call name="update#mantle.work.effort.WorkEffort" in-map="[workEffortId:workEffortId,resolutionEnumId:resolutionEnumId,actualCompletionDate:actualCompletionDate]"/>
<!--                    <log message="Updating task ${workEffortId} to ${resolutionEnumId}"/>-->
                </if>

                <entity-find-one entity-name="mantle.work.effort.WorkEffort" value-field="project" auto-field-map="[workEffortId:task.rootWorkEffortId]"/>
                <if condition="!project.actualCompletionDate">
                    <entity-find-count entity-name="mantle.work.effort.WorkEffort" count-field="taskCount">
                        <econdition field-name="rootWorkEffortId" from="task.rootWorkEffortId"/></entity-find-count>
                    <entity-find-count entity-name="mantle.work.effort.WorkEffort" count-field="taskWithResolutionCount">
                        <econdition field-name="rootWorkEffortId" from="task.rootWorkEffortId"/>
                        <econdition field-name="resolutionEnumId" operator="is-not-null"/></entity-find-count>
                    <if condition="taskWithResolutionCount == taskCount">
                        <service-call name="update#mantle.work.effort.WorkEffort" in-map="[workEffortId:task.rootWorkEffortId,actualCompletionDate:ec.user.nowTimestamp]"/>
<!--                        <log message="Completing project ${task.rootWorkEffortId}"/>-->
                        <else>
                            <entity-find entity-name="mantle.work.effort.WorkEffort" list="taskList" limit="1">
                                <econdition field-name="rootWorkEffortId" from="task.rootWorkEffortId"/>
                                <econdition field-name="workEffortId" operator="greater"/>
                                <order-by field-name="workEffortId"/></entity-find>

                            <if condition="taskList?.size() &gt; 0 &amp;&amp; taskList?.getFirst()?.resolutionEnumId == null">
                                <entity-find entity-name="mantle.work.effort.WorkEffortAndPartyDetail" list="userAccountList">
                                    <date-filter/><econdition field-name="workEffortId" from="taskList?.getFirst()?.workEffortId"/>
                                    <econdition field-name="roleTypeId" value="Assignee"/>
                                    <select-field field-name="emailAddress,partyId"/>
                                    <order-by field-name="-fromDate"/></entity-find>

                                <if condition="userAccountList.size() &gt; 0 &amp;&amp;
                                        userAccountList?.getFirst()?.partyId != ec.user.userAccount.partyId
                                        &amp;&amp; userAccountList?.getFirst()?.emailAddress != null">
                                    <service-call name="coarchy.CoarchyServices.send#ContactListEmail" in-map="[
                                        contactListId:'CoarchyTaskReminder',emailTemplateId:'TASK_NOTIFICATION',
                                        partyId:userAccountList?.getFirst()?.partyId,
                                        toAddresses:userAccountList.getFirst().emailAddress,
                                        bodyParameters:[linkUrl:baseLinkUrl+'/coapp/Checklist?checklistId='+taskList?.getFirst().rootWorkEffortId,
                                        baseLinkUrl:baseLinkUrl,
                                        title:'Task '+taskList?.getFirst().workEffortName+' is ready']]" out-map="context"/>
                                </if>

                                <entity-find entity-name="mantle.work.effort.WorkEffortAndPartyDetail" list="userAccountOwnerList" limit="1">
                                    <date-filter/><econdition field-name="workEffortId" from="task.rootWorkEffortId"/>
                                    <econdition field-name="roleTypeId" value="Owner"/>
                                    <select-field field-name="emailAddress,partyId"/>
                                    <order-by field-name="-fromDate"/></entity-find>

                                <if condition="(userAccountList.size() == 0)">
                                    <if condition="(userAccountOwnerList.size() &gt; 0) &amp;&amp;
                                        userAccountOwnerList?.getFirst()?.partyId != ec.user.userAccount.partyId
                                        &amp;&amp; userAccountOwnerList?.getFirst()?.emailAddress != null">
                                        <service-call name="coarchy.CoarchyServices.send#ContactListEmail" in-map="[
                                            contactListId:'CoarchyTaskReminder',emailTemplateId:'TASK_NEEDS_ASSIGNMENT_NOTIFICATION',
                                            partyId:userAccountOwnerList?.getFirst()?.partyId,
                                            toAddresses:userAccountOwnerList.getFirst().emailAddress,
                                            bodyParameters:[linkUrl:baseLinkUrl+'/coapp/Checklist?checklistId='+taskList?.getFirst().rootWorkEffortId,
                                            baseLinkUrl:baseLinkUrl,
                                            title:'Task '+taskList?.getFirst().workEffortName+' is ready to be assigned']]" out-map="context"/>
                                    </if>
                                </if>
                            </if>
                        </else>
                    </if>
                </if>
            </if>

        </actions>
    </service>
    <service verb="assign" noun="AllTasks">
        <in-parameters>
            <parameter name="workEffortId" required="true"/>
            <parameter name="actorId" required="true"/>
            <parameter name="partyId" required="true"/>
            <parameter name="organizationId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="workEffortId"/>
            <parameter name="returnToScreen"/>
        </out-parameters>
        <actions>
            <entity-find entity-name="coarchy.WorkEffortActivityDetail" list="taskList" distinct="true">
                <date-filter/><econdition field-name="rootWorkEffortId" from="workEffortId"/>
                <econdition field-name="workEffortTypeEnumId" value="WetChecklistItem"/>
                <econdition field-name="workEffortTypeEnumId" value="WetChecklistItem"/>
                <econdition field-name="actorId"/>
                <econdition field-name="roleTypeId" operator="is-null"/>
                <econdition field-name="resolutionEnumId" operator="is-null"/>
                <select-field field-name="workEffortId"/>
                <order-by field-name="workEffortId"/></entity-find>
            <if condition="!taskList"><return type="warning" message="No tasks found"/></if>

            <iterate list="taskList" entry="task">
                <service-call name="coarchy.CoarchyServices.update#Task" in-map="[workEffortId:task.workEffortId,assignedPartyIdList:[partyId],organizationId:organizationId]"/>
            </iterate>

            <entity-find-count entity-name="WorkEffort" count-field="workEffortCount" distinct="true">
                <econdition field-name="rootWorkEffortId" from="workEffortId"/>
                <econdition field-name="workEffortTypeEnumId" value="WetChecklistItem"/>
                <select-field field-name="workEffortId"/></entity-find-count>
            <entity-find-count entity-name="WorkEffortAndParty" count-field="workEffortPartyCount" distinct="true">
                <date-filter/><econdition field-name="rootWorkEffortId" from="workEffortId"/>
                <econdition field-name="roleTypeId" value="Assignee"/>
                <select-field field-name="workEffortId,roleTypeId"/></entity-find-count>
            <set field="returnToScreen" from="workEffortCount==workEffortPartyCount"/>
        </actions>
    </service>

    <service verb="create" noun="Actor">
        <in-parameters>
            <parameter name="name" required="true"/>
            <parameter name="description"/>
            <parameter name="partyIdList" type="List"/>
            <parameter name="organizationId" required="true"/>
            <parameter name="isOwner" required="true" type="Boolean"/>
        </in-parameters>
        <out-parameters>
            <parameter name="actorId"/>
            <parameter name="partyIdList" type="List"/>
        </out-parameters>
        <actions>
            <set field="name" from="name.trim()"/>
            <set field="description" from="description?.trim()"/>
            <entity-find entity-name="coarchy.Actor" list="actorList" limit="20">
                <!-- NOTE: ignore case but don't do like for contains, makes things like "Customer" after "Placing Customer" an error -->
                <econdition field-name="name" from="name" ignore-case="true"/>
            </entity-find>
            <if condition="actorList"><return type="danger" message="Actor '${actorList?.getFirst()?.name}' already exists"/></if>

            <service-call name="create#coarchy.Actor" in-map="[name:name,description:description,organizationId:organizationId]" out-map="context"/>
            <if condition="isOwner">
                <iterate list="partyIdList" entry="partyId">
                    <service-call name="create#coarchy.ActorParty" in-map="[actorId:actorId,partyId:partyId,organizationId:organizationId]"/>
                </iterate>
            </if>
        </actions>
    </service>
    <service verb="update" noun="Actor">
        <in-parameters>
            <parameter name="actorId" required="true"/>
            <parameter name="name" required="true"/>
            <parameter name="description"/>
            <parameter name="partyIdList" type="List"/>
            <parameter name="organizationId" required="true"/>
            <parameter name="isOwner" required="true" type="Boolean"/>
        </in-parameters>
        <out-parameters>
            <parameter name="actorId"/>
        </out-parameters>
        <actions>
            <set field="name" from="name.trim()"/>
            <set field="description" from="description?.trim()"/>
            <entity-find entity-name="coarchy.Actor" list="actorList" limit="20">
                <!-- NOTE: ignore case but don't do like for contains, makes things like "Customer" after "Placing Customer" an error -->
                <econdition field-name="actorId" operator="not-equals"/>
                <econdition field-name="name" from="name" ignore-case="true"/>
            </entity-find>
            <if condition="actorList"><return type="danger" message="Actor '${actorList?.getFirst()?.name}' already exists"/></if>

            <service-call name="update#coarchy.Actor" in-map="[actorId:actorId,name:name,description:description,organizationId:organizationId]"/>

            <if condition="isOwner">
                <entity-find entity-name="coarchy.ActorParty" list="actorPartyList">
                    <econdition field-name="actorId"/>
                    <order-by field-name="actorId"/>
                </entity-find>

                <set field="partyIdServerList" from="actorPartyList*.partyId"/>
                <if condition="partyIdServerList">
                    <set field="partyIdDeleteList" from="partyIdServerList - partyIdList?:[]"/>

                    <!--                                                    <log level="warn" message="partyIdDeleteList ${partyIdDeleteList}"/>-->
                    <iterate list="partyIdDeleteList" entry="partyIdDelete">
                        <service-call name="delete#coarchy.ActorParty" in-map="[actorId:actorId,partyId:partyIdDelete]"/>
                    </iterate>
                </if>

                <set field="partyIdCreateList" from="partyIdList?:[] - partyIdDeleteList?:[]"/>
                <!--                        <log level="warn" message="update#Actor context.toString() ${context.toString()}"/>-->
                <if condition="partyIdCreateList instanceof String">
                    <then>
                        <service-call name="store#coarchy.ActorParty" in-map="[actorId:actorId, partyId:partyIdCreateList, organizationId:organizationId]"/>
                    </then><else>
                    <iterate list="partyIdCreateList" entry="partyIdCreate">
                        <service-call name="store#coarchy.ActorParty" in-map="[actorId:actorId, partyId:partyIdCreate, organizationId:organizationId]"/>
                    </iterate>
                </else></if>
            </if>
        </actions>
    </service>

    <service verb="create" noun="ValueStatement">
        <in-parameters>
            <parameter name="value" required="true"/>
            <parameter name="typeEnumId" required="true"/>
            <parameter name="organizationId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="valueStatementId"/>
        </out-parameters>
        <actions>
            <set field="value" from="value.trim()"/>
            <entity-find entity-name="coarchy.ValueStatement" list="valueStatementList" limit="20">
                <!-- NOTE: ignore case but don't do like for contains, makes things like "Customer" after "Placing Customer" an error -->
                <econdition field-name="value" from="value" ignore-case="true"/>
            </entity-find>
            <if condition="valueStatementList"><return type="danger" message="Value Statement '${valueStatementList?.getFirst()?.value}' already exists"/></if>

            <entity-find entity-name="coarchy.ValueStatement" list="valueStatementList" limit="1">
                <!-- NOTE: ignore case but don't do like for contains, makes things like "Customer" after "Placing Customer" an error -->
                <order-by field-name="-sequenceNum,value"/>
            </entity-find>

            <service-call name="create#coarchy.ValueStatement" in-map="[value:value,typeEnumId:typeEnumId,
                sequenceNum:valueStatementList.getFirst()?.sequenceNum?valueStatementList.getFirst()?.sequenceNum+1:1,organizationId:organizationId]"/>
        </actions>
    </service>
    <service verb="create" noun="ActivityValue">
        <in-parameters>
            <parameter name="activityId" required="true"/>
            <parameter name="valueIdList" type="List"/>
            <parameter name="organizationId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="valueStatementId"/>
        </out-parameters>
        <actions>
            <entity-find entity-name="coarchy.ValueStatementActivity" list="valueStatementActivityList">
                <econdition field-name="activityId"/>
                <order-by field-name="name"/></entity-find>
            <set field="valueIdServerList" from="valueStatementActivityList*.valueStatementId"/>
            <if condition="valueIdServerList">
                <set field="valueIdDeleteList" from="valueIdServerList - valueIdList?:[]"/>

                <!--                                    <log level="warn" message="activityIdDeleteList ${activityIdDeleteList}"/>-->
                <iterate list="valueIdDeleteList" entry="valueIdDelete">
                    <set field="valueStatementActivity" from="valueStatementActivityList.find{it.valueStatementId == valueIdDelete}"/>
                    <if condition="valueStatementActivity"><then>
                        <service-call name="delete#coarchy.ValueStatementActivity" in-map="[valueStatementActivityId:valueStatementActivity.valueStatementActivityId]"/>
                    </then><else>
                        <message type="warning" error="true">Unable to delete value connection ${valueId}</message>
                    </else></if>
                </iterate>
            </if>

            <set field="valueIdCreateList" from="valueIdList?:[] - valueIdDeleteList?:[]"/>
            <!--            <log level="warn" message="update#ValueStatement context.toString() ${context.toString()}"/>-->
            <if condition="valueIdCreateList instanceof String">
                <then>
                    <service-call name="store#coarchy.ValueStatementActivity" in-map="[valueStatementActivityId:valueStatementActivityList.find{it.valueStatementId == valueIdCreateList}?.valueStatementActivityId,valueStatementId:valueIdCreateList, activityId:activityId, organizationId:organizationId]"/>
                </then><else>
                <iterate list="valueIdCreateList" entry="valueIdCreate">
                    <service-call name="store#coarchy.ValueStatementActivity" in-map="[valueStatementActivityId:valueStatementActivityList.find{it.valueStatementId == valueIdCreate}?.valueStatementActivityId,valueStatementId:valueIdCreate, activityId:activityId, organizationId:organizationId]"/>
                </iterate>
            </else>
            </if>
        </actions>
    </service>
    <service verb="update" noun="ValueStatement">
        <in-parameters>
            <parameter name="valueStatementId" required="true"/>
            <parameter name="value" required="true"/>
            <parameter name="activityIdList" type="List"/>
            <parameter name="typeEnumId"/>
            <parameter name="sequenceNum"/>
            <parameter name="organizationId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="valueStatementId"/>
        </out-parameters>
        <actions>
            <set field="value" from="value.trim()"/>
            <entity-find entity-name="coarchy.ValueStatement" list="valueStatementList" limit="20">
                <!-- NOTE: ignore case but don't do like for contains, makes things like "Customer" after "Placing Customer" an error -->
                <econdition field-name="valueStatementId" operator="not-equals"/>
                <econdition field-name="value" from="value" ignore-case="true"/>
            </entity-find>
            <if condition="valueStatementList"><return type="danger" message="Value Statement '${valueStatementList?.getFirst()?.value}' already exists"/></if>

            <service-call name="update#coarchy.ValueStatement" in-map="[valueStatementId:valueStatementId,value:value,typeEnumId:typeEnumId,sequenceNum:sequenceNum,organizationId:organizationId]" out-map="context"/>

            <entity-find entity-name="coarchy.ValueStatementActivity" list="valueStatementActivityList">
                <econdition field-name="valueStatementId"/>
                <order-by field-name="name"/></entity-find>
            <set field="activityIdServerList" from="valueStatementActivityList*.activityId"/>
            <if condition="activityIdServerList">
                <set field="activityIdDeleteList" from="activityIdServerList - activityIdList?:[]"/>

                <!--                                    <log level="warn" message="activityIdDeleteList ${activityIdDeleteList}"/>-->
                <iterate list="activityIdDeleteList" entry="activityIdDelete">
                    <entity-find-one entity-name="ValueStatementActivity" value-field="valueStatementActivity" auto-field-map="[activityId:activityIdDelete,valueStatementId:valueStatementId]"/>
                    <if condition="valueStatementActivity"><then>
                        <service-call name="delete#coarchy.ValueStatementActivity" in-map="[valueStatementActivityId:valueStatementActivity.valueStatementActivityId]"/>
                    </then><else>
                        <message type="warning">Unable to delete activity connection ${activityId}</message>
                    </else></if>
                </iterate>
            </if>

            <set field="activityIdCreateList" from="activityIdList?:[] - activityIdDeleteList?:[]"/>
<!--            <log level="warn" message="update#ValueStatement context.toString() ${context.toString()}"/>-->
            <if condition="activityIdCreateList instanceof String">
                <then>
                    <entity-find-one entity-name="ValueStatementActivity" value-field="valueStatementActivity" auto-field-map="[activityId:activityIdCreateList,valueStatementId:valueStatementId]"/>
                    <service-call name="store#coarchy.ValueStatementActivity" in-map="[valueStatementActivityId:valueStatementActivity?.valueStatementActivityId,valueStatementId:valueStatementId, activityId:activityIdCreateList, organizationId:organizationId]"/>
                </then><else>
                    <iterate list="activityIdCreateList" entry="activityIdCreate">
                        <entity-find-one entity-name="ValueStatementActivity" value-field="valueStatementActivity" auto-field-map="[activityId:activityIdCreate,valueStatementId:valueStatementId]"/>
                        <service-call name="store#coarchy.ValueStatementActivity" in-map="[valueStatementActivityId:valueStatementActivity?.valueStatementActivityId,valueStatementId:valueStatementId, activityId:activityIdCreate, organizationId:organizationId]"/>
                    </iterate>
                </else>
            </if>
        </actions>
    </service>
    <service verb="delete" noun="ValueStatement">
        <in-parameters>
            <parameter name="valueStatementId" required="true"/>
            <parameter name="organizationId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="valueStatementId"/>
        </out-parameters>
        <actions>
            <entity-find-count entity-name="coarchy.ValueStatementActivity" count-field="valueStatementActivityCount">
                <econdition field-name="valueStatementId"/></entity-find-count>
            <if condition="valueStatementActivityCount &gt; 0">
                <return type="warning" message="Cannot delete an Value Statement with Process Story Activities"/>
            </if>
            <entity-find-one entity-name="coarchy.ValueStatement" value-field="valueStatement" auto-field-map="[valueStatementId:valueStatementId,organizationId:organizationId]"/>

            <if condition="valueStatement">
                <service-call name="delete#coarchy.ValueStatement" in-map="[valueStatementId:valueStatementId]"/>
            </if>
        </actions>
    </service>

    <service verb="update" noun="User">
        <in-parameters>
            <parameter name="partyId" required="true"/>
            <parameter name="actorIdList" type="List"/>
            <parameter name="organizationId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="partyId"/>
        </out-parameters>
        <actions>
            <entity-find entity-name="coarchy.ActorParty" list="actorPartyList">
                <econdition field-name="partyId"/>
                <econdition field-name="organizationId"/>
            </entity-find>
            <set field="actorIdServerList" from="actorPartyList*.actorId"/>
            <if condition="actorIdServerList">
                <set field="actorIdDeleteList" from="actorIdServerList - actorIdList?:[]"/>
<!--                                                                    <log level="warn" message="actorIdDeleteList ${actorIdDeleteList}"/>-->
                <iterate list="actorIdDeleteList" entry="actorIdDelete">
                    <service-call name="delete#coarchy.ActorParty" in-map="[actorId:actorIdDelete,partyId:partyId]"/>
                </iterate>
            </if>
            <set field="actorIdCreateList" from="actorIdList?:[] - actorIdDeleteList?:[]"/>
            <!--                        <log level="warn" message="update#Actor context.toString() ${context.toString()}"/>-->
            <if condition="actorIdCreateList instanceof String">
                <then>
                    <service-call name="store#coarchy.ActorParty" in-map="[actorId:actorIdCreateList, partyId:partyId, organizationId:organizationId]"/>
                </then><else>
                <iterate list="actorIdCreateList" entry="actorIdCreate">
                    <service-call name="store#coarchy.ActorParty" in-map="[actorId:actorIdCreate, partyId:partyId, organizationId:organizationId]"/>
                </iterate>
            </else></if>
        </actions>
    </service>

    <service verb="update" noun="Vision">
        <in-parameters>
            <parameter name="partyId" required="true"/>
            <parameter name="originStoryDescription"/>
            <parameter name="missionDescription"/>
            <parameter name="visionDescription"/>
        </in-parameters>
        <out-parameters>
            <parameter name="partyId"/>
            <parameter name="originStoryContentId"/>
            <parameter name="missionContentId"/>
            <parameter name="visionContentId"/>
        </out-parameters>
        <actions>
            <set field="originStoryDescription" from="originStoryDescription.trim()"/>
            <set field="missionDescription" from="missionDescription.trim()"/>
            <set field="visionDescription" from="visionDescription.trim()"/>

            <entity-find entity-name="mantle.party.PartyContent" list="originStoryList" limit="1">
                <econdition field-name="partyId"/>
                <econdition field-name="partyContentTypeEnumId" value="PcntOriginStory"/>
                <order-by field-name="-contentDate"/></entity-find>
            <if condition="originStoryList.size() == 0"><then>
                <service-call name="create#mantle.party.PartyContent" out-map="originStoryContent" in-map="[partyId:partyId,partyContentTypeEnumId:'PcntOriginStory',description:originStoryDescription]"/>
                <set field="originStoryContentId" from="originStoryContent.partyContentId"/>
            </then><else>
                <set field="originStoryContentId" from="originStoryList.getFirst().partyContentId"/>
                <service-call name="update#mantle.party.PartyContent" out-map="originStoryContent" in-map="[partyContentId:originStoryContentId,description:originStoryDescription]"/>
            </else></if>

            <entity-find entity-name="mantle.party.PartyContent" list="missionList" limit="1">
                <econdition field-name="partyId"/>
                <econdition field-name="partyContentTypeEnumId" value="PcntMission"/>
                <order-by field-name="-contentDate"/></entity-find>
            <if condition="missionList.size() == 0"><then>
                <service-call name="create#mantle.party.PartyContent" out-map="missionContent" in-map="[partyId:partyId,partyContentTypeEnumId:'PcntMission',description:missionDescription]"/>
                <set field="missionContentId" from="missionContent.partyContentId"/>
            </then><else>
                <set field="missionContentId" from="missionList.getFirst().partyContentId"/>
                <service-call name="update#mantle.party.PartyContent" out-map="missionContent" in-map="[partyContentId:missionContentId,description:missionDescription]"/>
            </else></if>

            <entity-find entity-name="mantle.party.PartyContent" list="visionList" limit="1">
                <econdition field-name="partyId"/>
                <econdition field-name="partyContentTypeEnumId" value="PcntVision"/>
                <order-by field-name="-contentDate"/></entity-find>
            <if condition="visionList.size() == 0"><then>
                <service-call name="create#mantle.party.PartyContent" out-map="visionContent" in-map="[partyId:partyId,partyContentTypeEnumId:'PcntVision',description:visionDescription]"/>
                <set field="visionContentId" from="visionContent.partyContentId"/>
            </then><else>
                <set field="visionContentId" from="visionList.getFirst().partyContentId"/>
                <service-call name="update#mantle.party.PartyContent" out-map="visionContent" in-map="[partyContentId:visionContentId,description:visionDescription]"/>
            </else></if>
        </actions>
    </service>

    <service verb="add" noun="OrderProductQuantity" authenticate="anonymous-all">
        <!-- TODO had transaction="cache" but causing issues with updating single Payment amount and sometimes part/header total when there are multiple promotions active (ie New Customer and BOGO) -->
        <description>A service for an add-to-cart sort of operation, including:
            1. create an Order if no orderId is passed in
            2. determine the price to charge for the Product (and update based on quantity as needed)
            3. find a OrderItem matching the productId, and if found update quantity
            4. if no existing OrderItem is found create a new OrderItem
        </description>
        <in-parameters>
            <parameter name="orderId"/>
            <parameter name="orderPartSeqId"/>
            <!-- OrderHeader settings -->
            <parameter name="productStoreId"/>
            <parameter name="currencyUomId"/>
            <parameter name="salesChannelEnumId"/>
            <!-- OrderPart settings -->
            <parameter name="customerPartyId"/>
            <parameter name="carrierPartyId"/><parameter name="shipmentMethodEnumId"/>

            <parameter name="productId" required="true"/>
            <parameter name="description"/>
            <parameter name="quantity" type="BigDecimal"><description>Defaults to 1 if addToQuantity=true (default)</description></parameter>
            <parameter name="addToQuantity" type="Boolean" default="true">
                <description>If true add to existing quantity, if false set quantity on current item</description></parameter>
            <parameter name="updateExisting" type="Boolean" default="true">
                <description>If true update existing item by productId, if false always create a new item</description></parameter>
            <parameter name="requireInventory" type="Boolean">
                <description>If true make sure inventory is available, if false don't check. If null defer to ProductStore.requireInventory setting.</description></parameter>
            <parameter name="itemTypeEnumId" default-value="ItemProduct"/>
            <parameter name="unitAmount" type="BigDecimal"/>
            <parameter name="standardCost" type="BigDecimal"/>
            <parameter name="requiredByDate" type="Timestamp"/>
            <parameter name="otherPartyProductId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="orderPartSeqId" required="true"/>
            <parameter name="orderItemSeqId" required="true"/>
        </out-parameters>
        <actions>
            <if condition="quantity == null &amp;&amp; (addToQuantity || !updateExisting)"><set field="quantity" from="1.0"/></if>
            <!-- handle explicit zero quantity -->
            <if condition="(quantity == null || quantity &lt;= 0) &amp;&amp; updateExisting">
                <!-- do nothing if add -->
                <if condition="addToQuantity || !orderId"><return/></if>
                <!-- in set mode remove the item -->
                <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                    <econdition-object field="[orderId:orderId, orderPartSeqId:orderPartSeqId, productId:productId,
                        productConfigSavedId:null, forAssetId:null, selectedAmount:null]"/>
                </entity-find>
                <if condition="orderItemList">
                    <service-call name="mantle.order.OrderServices.delete#OrderItem"
                            in-map="[orderId:orderId, orderItemSeqId:orderItemList[0].orderItemSeqId]"/>
                </if>
                <return/>
            </if>

            <!-- lookup orderPartSeqId if not passed in -->
            <if condition="!orderPartSeqId &amp;&amp; orderId">
                <entity-find entity-name="mantle.order.OrderPart" list="orderPartList">
                    <econdition field-name="orderId"/>
                    <select-field field-name="orderPartSeqId"/>
                    <order-by field-name="orderPartSeqId"/>
                </entity-find>
                <set field="orderPartSeqId" from="orderPartList?.first?.orderPartSeqId"/>
            </if>

            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader" for-update="true"/>
            <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart" for-update="true"/>

            <set field="productStoreId" from="productStoreId ?: orderHeader?.productStoreId"/>
            <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore"/>
            <set field="vendorPartyId" from="orderPart?.vendorPartyId ?: productStore?.organizationPartyId"/>
            <set field="currencyUomId" from="currencyUomId ?: productStore?.defaultCurrencyUomId"/>
            <set field="salesChannelEnumId" from="salesChannelEnumId ?: productStore?.defaultSalesChannelEnumId"/>

            <!-- if orderPart.customerPartyId always use it, otherwise default to customerPartyId parameter or current user's partyId -->
            <set field="customerPartyId" from="(orderPart?.customerPartyId ?: customerPartyId) ?: ec.user.userAccount?.partyId"/>

            <if condition="!orderId">
<!--                <if condition="customerPartyId">-->
<!--                    <entity-find entity-name="mantle.order.OrderHeaderAndPart" list="existingOrderList">-->
<!--                        <econdition field-name="statusId" value="OrderOpen"/>-->
<!--                        <econdition field-name="customerPartyId"/>-->
<!--                        <econdition field-name="vendorPartyId" ignore-if-empty="true"/>-->
<!--                        <econdition field-name="productStoreId" ignore-if-empty="true"/>-->
<!--                        <select-field field-name="orderId"/><select-field field-name="orderPartSeqId"/>-->
<!--                        <order-by field-name="-entryDate"/>&lt;!&ndash; get most recent open order &ndash;&gt;-->
<!--                    </entity-find>-->
<!--                    <if condition="existingOrderList">-->
<!--                        <set field="orderId" from="existingOrderList[0].orderId"/>-->
<!--                        <set field="orderPartSeqId" from="existingOrderList[0].orderPartSeqId"/>-->

<!--                        <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>-->
<!--                        <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart"/>-->
<!--                    </if>-->
<!--                </if>-->
                <!-- no existing open (cart) order found? create one -->
                <if condition="!orderId">
                    <service-call name="mantle.order.OrderServices.create#Order" out-map="createOrderOut"
                            in-map="[currencyUomId:currencyUomId, productStoreId:productStoreId, salesChannelEnumId:salesChannelEnumId,
                                vendorPartyId:vendorPartyId, customerPartyId:customerPartyId, carrierPartyId:carrierPartyId,
                                shipmentMethodEnumId:shipmentMethodEnumId]"/>
                    <set field="orderId" from="createOrderOut.orderId"/>
                    <set field="orderPartSeqId" from="createOrderOut.orderPartSeqId"/>

                    <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>
                    <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart"/>
                </if>
            </if>

            <!-- calculate the price based on quantity, etc, -->
            <if condition="unitAmount == null"><then>
                <!-- use PriceServices.get#OrderProductPrice instead of calling to get price directly, for pricePurposeEnumId override for recurring orders and other future behavior:
                <service-call name="mantle.product.PriceServices.get#ProductPrice" out-map="priceMap"
                              in-map="[productId:productId, quantity:quantity, priceUomId:currencyUomId,
                         productStoreId:productStoreId, customerPartyId:customerPartyId, vendorPartyId:vendorPartyId]"/>
                -->
                <service-call name="mantle.product.PriceServices.get#OrderProductPrice" out-map="priceMap"
                        in-map="[productId:productId, quantity:quantity, orderId:orderId, orderPartSeqId:orderPartSeqId]"/>

                <set field="unitAmount" from="priceMap.price"/>
                <set field="unitListPrice" from="priceMap.listPrice"/>
                <set field="productPriceId" from="priceMap.productPriceId"/>
                <set field="isModifiedPrice" value="N"/>
                <log message="OrderProductQuantity Calculated Order ${orderId}:${orderPartSeqId} Product ${productId} calculated unitAmount ${unitAmount} unitListPrice ${unitListPrice} productStoreId ${productStoreId} customerPartyId ${customerPartyId} vendorPartyId ${vendorPartyId}"/>
            </then><else>
                <log message="OrderProductQuantity Modified Order ${orderId}:${orderPartSeqId} Product ${productId} manual unitAmount ${unitAmount}"/>
                <set field="isModifiedPrice" value="Y"/>
            </else></if>

            <!-- look up otherPartyProductId if not specified - first from ProductParty then ProductPrice -->
            <if condition="!otherPartyProductId &amp;&amp; productId">
                <entity-find-one entity-name="mantle.party.PartyRole" value-field="vendorOrgRole">
                    <field-map field-name="partyId" from="orderPart.vendorPartyId"/>
                    <field-map field-name="roleTypeId" value="OrgInternal"/>
                </entity-find-one>
                <if condition="vendorOrgRole != null &amp;&amp; orderPart.customerPartyId"><then>
                    <entity-find entity-name="mantle.product.ProductParty" list="otherPartyItemIdList" cache="false">
                        <date-filter/><econdition field-name="productId"/>
                        <econdition field-name="partyId" from="orderPart.customerPartyId"/>
                        <econdition field-name="roleTypeId" value="Customer"/>
                        <econdition field-name="otherPartyItemId" operator="is-not-null"/>
                    </entity-find>
                    <if condition="otherPartyItemIdList"><then>
                        <set field="otherPartyProductId" from="otherPartyItemIdList[0].otherPartyItemId"/>
                    </then><else>
                        <!-- NOTE: consider removing this, ProductParty a better place, but would not be backward compatible -->
                        <entity-find entity-name="mantle.product.ProductPrice" list="otherPartyItemIdList" cache="false">
                            <date-filter/><econdition field-name="productId"/>
                            <econdition field-name="customerPartyId" from="orderPart.customerPartyId"/>
                            <econdition field-name="otherPartyItemId" operator="is-not-null"/>
                        </entity-find>
                        <if condition="otherPartyItemIdList">
                            <set field="otherPartyProductId" from="otherPartyItemIdList[0].otherPartyItemId"/></if>
                    </else></if>
                </then><else-if condition="vendorOrgRole == null &amp;&amp; orderPart.vendorPartyId">
                    <entity-find entity-name="mantle.product.ProductParty" list="otherPartyItemIdList" cache="false">
                        <date-filter/><econdition field-name="productId"/>
                        <econdition field-name="partyId" from="orderPart.vendorPartyId"/>
                        <econdition field-name="roleTypeId" value="Supplier"/>
                        <econdition field-name="otherPartyItemId" operator="is-not-null"/>
                    </entity-find>
                    <if condition="otherPartyItemIdList"><then>
                        <set field="otherPartyProductId" from="otherPartyItemIdList[0].otherPartyItemId"/>
                    </then><else>
                        <!-- NOTE: consider removing this, ProductParty a better place, but would not be backward compatible -->
                        <entity-find entity-name="mantle.product.ProductPrice" list="otherPartyItemIdList" cache="false">
                            <date-filter/><econdition field-name="productId"/>
                            <econdition field-name="vendorPartyId" from="orderPart.vendorPartyId"/>
                            <econdition field-name="otherPartyItemId" operator="is-not-null"/>
                        </entity-find>
                        <if condition="otherPartyItemIdList">
                            <set field="otherPartyProductId" from="otherPartyItemIdList[0].otherPartyItemId"/></if>
                    </else></if>
                </else-if></if>
            </if>

            <!-- find an OrderItem for the productId and increment quantity if found, otherwise create OrderItem with quantity -->
            <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                <econdition field-name="orderId"/><econdition field-name="orderPartSeqId"/>
                <econdition field-name="productId"/>
                <econdition field-name="itemTypeEnumId" value="ItemProduct"/>
                <econdition field-name="fromAssetId" operator="is-null"/>
                <econdition field-name="selectedAmount" operator="is-null"/>
                <!-- for future reference: <econdition field-name="productConfigSavedId" operator="is-null"/> -->
                <order-by field-name="orderItemSeqId"/>
            </entity-find>

            <if condition="orderItemList &amp;&amp; updateExisting"><then>
                <set field="orderItem" from="orderItemList.first"/>
                <set field="orderItemSeqId" from="orderItem.orderItemSeqId"/>
                <set field="orderPartSeqId" from="orderItem.orderPartSeqId" set-if-empty="false"/>
                <set field="unitAmount" from="unitAmount != null ? unitAmount : orderItem.unitAmount"/>
                <set field="standardCost" from="standardCost != null ? standardCost : orderItem.standardCost"/>
                <set field="quantity" from="addToQuantity ? quantity + orderItem.quantity : quantity"/>
                <!-- if requiredByDate on orderItem is less than that passed in, make sure to use it instead of the new later one -->
                <if condition="orderItem.requiredByDate &amp;&amp; requiredByDate &amp;&amp; orderItem.requiredByDate &lt; requiredByDate">
                    <set field="requiredByDate" from="orderItem.requiredByDate"/></if>
                <service-call name="mantle.order.OrderServices.update#OrderItem" in-map="context"/>
            </then><else>
                <service-call name="mantle.order.OrderServices.create#OrderItem" in-map="context" out-map="createOrderItemOut"/>
                <set field="orderItemSeqId" from="createOrderItemOut.orderItemSeqId"/>
            </else></if>
        </actions>
    </service>
    <service verb="buy" noun="OrganizationMonthCredits">
        <in-parameters>
            <parameter name="quantity" required="true" type="Integer"/>
            <parameter name="productId" default-value="c100000"/>
        </in-parameters>
        <out-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="orderPartSeqId" required="true"/>
            <parameter name="orderItemSeqId" required="true"/>
        </out-parameters>
        <actions>
            <if condition="quantity &lt; 1"><return type="danger" message="Organization-Month Quantity must at least 1" error="true" public="true"/></if>
            <if condition="quantity &gt; 18"><return type="danger" message="Cannot buy more than 18 Organization-Month Credits" error="true" public="true"/></if>
            <entity-find entity-name="mantle.product.store.ProductStoreProduct" list="productStoreProductList" limit="1">
                <econdition field-name="productId"/><order-by field-name="-lastUpdatedStamp"/></entity-find>
            <service-call name="coarchy.CoarchyServices.add#OrderProductQuantity" in-map="[quantity:quantity,productId:productId,
                productStoreId:productStoreProductList.getFirst()?.productStoreId,addToQuantity:false]" out-map="context"/>
        </actions>
    </service>
    <service verb="deposit" noun="OrderToFinancialAccount">
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <auto-parameters entity-name="mantle.order.OrderHeader" include="nonpk"/>
        </in-parameters>
        <actions>
<!--            <log level="warn" message="deposit#OrderToFinancialAccount context.toString() ${context.toString()}"/>-->

            <entity-find entity-name="mantle.order.OrderItemAndPart" list="orderItemPartList">
                <econdition field-name="orderId"/>
                <econdition field-name="itemTypeEnumId" value="ItemProduct"/>
                <econdition field-name="productId" value="c100000"/>
                <order-by field-name="orderItemSeqId"/></entity-find>
            <if condition="orderItemPartList.size() == 0"><return type="warning" message="No Organization-Month Items found for order"/></if>

            <iterate list="orderItemPartList" entry="orderItemPart">
                <!-- find financial accounts for the user who bought the order items or create financial account if not already exists -->
                <service-call name="mantle.account.FinancialAccountServices.getOrCreate#FinancialAccount" in-map="[
                        finAccountTypeId:'OrganizationMonthCredit',organizationPartyId:'coarchy',
                        ownerPartyId:orderItemPart.customerPartyId,currencyUomId:'DSM']" out-map="context"/>

                <service-call name="mantle.account.FinancialAccountServices.deposit#FinancialAccount" in-map="[
                        finAccountId:finAccountId,amount:orderItemPart.quantity,orderId:orderId,
                        orderItemSeqId:orderItemPart.orderItemSeqId]"/>
            </iterate>

            <set field="partsAlreadyInvoiced" from="[]"/>
            <iterate list="orderItemPartList" entry="orderItemPart">
                <if condition="partsAlreadyInvoiced.contains(orderItemPart.orderPartSeqId)"><continue/></if>
                <service-call name="mantle.account.InvoiceServices.create#EntireOrderPartInvoice" in-map="[orderId:orderId,
                    orderPartSeqId:orderItemPart.orderPartSeqId,statusId:'InvoiceFinalized']" out-map="context"/>
                <set field="partsAlreadyInvoiced" from="partsAlreadyInvoiced + [orderItemPart.orderPartSeqId]"/>
            </iterate>

            <service-call name="mantle.order.OrderServices.complete#Order" in-map="[orderId:orderId]"/>

            <!-- Sales Journey Paying Customer user -->
            <service-call name="mantle.party.PartyServices.set#PartyClassification" in-map="[partyId:partyId,partyClassificationId:'PayingCustomer']" out-map="context"/>
        </actions>
    </service>
    <service verb="activateOrDeactivate" noun="Organization">
        <in-parameters>
            <parameter name="organizationPartyId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="needsCredits" type="Boolean"/>
            <parameter name="creditsNeeded" type="Integer"/>
        </out-parameters>
        <actions>
            <entity-find entity-name="mantle.party.Party" list="organizationPartyList">
                <econdition field-name="partyId" from="organizationPartyId"/>
                <econdition field-name="ownerPartyId" from="ec.user.userAccount.partyId"/>
            </entity-find>
            <if condition="organizationPartyList.size() == 0"><return type="danger" message="Cannot activate organization you do not own"/></if>

            <entity-find entity-name="mantle.party.PartyActivation" list="partyActivationList">
                <econdition field-name="partyId" from="organizationPartyId"/>
                <date-filter/></entity-find>

            <if condition="partyActivationList.size() == 0"><then>
                <service-call name="coarchy.CoarchyServices.check#PartyActivation" in-map="[userPartyId:ec.user.userAccount?.partyId, finAccountTypeId:'OrganizationMonthCredit']" out-map="context"/>
                <if condition="needsCredits"><then>
                    <return type="warning" public="true"
                            message="Can't activate organization. Buy at least ${creditsNeeded} Organization-Month Credits to get premium"/>
                </then><else>
                    <service-call name="create#mantle.party.PartyActivation" in-map="[partyId:organizationPartyId,
                        fromDate:ec.user.nowTimestamp]"/>
                </else></if>
            </then><else>
                <service-call name="update#mantle.party.PartyActivation" in-map="[partyId:organizationPartyId,
                    fromDate:partyActivationList.getFirst().fromDate,thruDate:ec.user.nowTimestamp]"/>
            </else></if>
        </actions>
    </service>
    <service verb="calculate" noun="PartyActivationUsage">
        <description>This will find all the PartyActivation records that have any time between their from or thru date
            within the given period from and thru dates. For each day that there is activation time, if it is at least
            minActivationMinutesPerDay then count it as a day. Then return the activation days / the total days between
            period.</description>
        <in-parameters>
            <parameter name="organizationPartyId" required="true"/>
            <parameter name="periodFromDate" type="Timestamp" required="true">
                <description>(inclusive) Start of the period to calculate activation. Rounded to midnight in default system timezone.</description></parameter>
            <parameter name="periodThruDate" type="Timestamp" required="true">
                <description>(exclusive) End of the period to calculate time period. Rounded to midnight subtracted 1 millisecond in default system timezone.</description></parameter>
            <parameter name="activationThruDate" type="Timestamp" default="periodThruDate" required="true">
                <description>(exclusive) End of the period to calculate activation. Rounded to midnight subtracted 1 millisecond in default system timezone.</description></parameter>
            <parameter name="minActivationMinutesPerDay" type="Long" default-value="5" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="activationPeriodCount" type="BigDecimal" required="true"><description>The time the organization was active
                during the period where 1 is 100% of the days and .5 is 50% of the days that at least
                minActivationMinutesPerDay was active</description></parameter>
            <parameter name="dayAmountList" type="List" required="true"/>
            <parameter name="dayCount" type="BigDecimal" required="true"/>
            <parameter name="totalDays" type="BigDecimal" required="true"/>
        </out-parameters>
        <actions>
            <if condition="periodFromDate &gt;= periodThruDate"><return type="danger" error="true"
                    message="Period From Date must be before Period Thru Date"/></if>
            <if condition="activationThruDate &gt; periodThruDate">
                <set field="activationThruDate" from="periodThruDate"/></if>

            <!-- Create a list of all the days between the period from and thru dates with the start of day at midnight
            timestamp and amount of milliseconds (defaulted to 0)-->
            <set field="periodFromDateZoned" from="ZonedDateTime.ofInstant(Instant.ofEpochMilli(
                (long) periodFromDate.time), ZoneId.systemDefault()).with(LocalTime.MIN)"/>
            <set field="periodThruDateZoned" from="ZonedDateTime.ofInstant(Instant.ofEpochMilli(
                (long) periodThruDate.time-1L), ZoneId.systemDefault()).with(LocalTime.MIN)"/>
            <set field="activationThruDateZoned" from="ZonedDateTime.ofInstant(Instant.ofEpochMilli(
                (long) activationThruDate.time-1L), ZoneId.systemDefault()).with(LocalTime.MIN)"/>
            <set field="dayList" from="[[dateTime:periodFromDateZoned,amount:0L]]" type="List"/>
            <set field="daysIndex" from="0"/>
            <set field="daysBetweenPeriod" from="java.time.temporal.ChronoUnit.DAYS.between(
                periodFromDateZoned, periodThruDateZoned)" type="BigDecimal"/>
            <if condition="daysBetweenPeriod==0"><set field="daysBetweenPeriod" from="1.0"/></if>
            <while condition="daysIndex &lt; daysBetweenPeriod">
                <set field="dayList" from="dayList + [dateTime:dayList[daysIndex].dateTime.plusDays(1),amount:0L]"/>
                <set field="daysIndex" from="daysIndex + 1"/>
            </while>

            <!-- Find all activation records are found within the time period and put into a list-->
            <entity-find entity-name="mantle.party.PartyActivation" list="partyActivationList">
                <econdition field-name="partyId" from="organizationPartyId"/>
                <econdition field-name="fromDate" operator="greater-equals" from="new Timestamp(periodFromDateZoned.toInstant().toEpochMilli())"/>
                <econdition field-name="fromDate" operator="less" from="new Timestamp(periodThruDateZoned.toInstant().toEpochMilli())"/>
                <order-by field-name="fromDate"/></entity-find>
            <entity-find entity-name="mantle.party.PartyActivation" list="partyActivation1List" limit="1">
                <econdition field-name="partyId" from="organizationPartyId"/>
                <econdition field-name="fromDate" operator="less" from="new Timestamp(periodFromDateZoned.toInstant().toEpochMilli())"/>
                <econdition field-name="thruDate" operator="greater-equals" from="new Timestamp(periodFromDateZoned.toInstant().toEpochMilli())" or-null="true"/>
                <order-by field-name="-fromDate"/></entity-find>
            <set field="partyActivationList" from="partyActivation1List + partyActivationList"/>
            <if condition="partyActivationList.size() == 0">
                <set field="activationPeriodCount" from="0.0" type="BigDecimal"/>
                <return/>
            </if>

            <!-- For each activation record, find the days that it is active and add the amount of milliseconds to the
            day's amount. If the activation record is active for more than one day, then add the amount of milliseconds
            to each day.-->
            <set field="firstPartyActivation" from="partyActivationList.getFirst()"/>
            <set field="firstDay" from="dayList[0]"/>
            <if condition="firstPartyActivation.fromDate.toInstant() &lt; firstDay.dateTime.toInstant()"><then>
                <set field="daysIndex" from="0"/>
            </then><else>
                <set field="daysIndex" from="java.time.temporal.ChronoUnit.DAYS.between(firstDay.dateTime,
                    ZonedDateTime.ofInstant(Instant.ofEpochMilli((long) firstPartyActivation.fromDate.time),
                    ZoneId.systemDefault()))"/>
            </else></if>

<!--            <log level="warn" message="calculate#PartyActivationUsage daysIndex ${daysIndex}"/>-->
            <iterate list="partyActivationList" entry="partyActivation">

<!--                <log level="warn" message="calculate#PartyActivationUsage partyActivation ${partyActivation}"/>-->
                <set field="partyActivationThruDate" from="partyActivation.thruDate ?: new Timestamp(dayList[dayList.size()-1].dateTime.plusDays(1).toInstant().toEpochMilli())"/>
                <if condition="partyActivationThruDate.toInstant() &gt; activationThruDateZoned.toInstant()">
                    <set field="partyActivationThruDate" from="new Timestamp(activationThruDateZoned.toInstant().toEpochMilli())"/>
                </if>

                <while condition="daysIndex &lt;= daysBetweenPeriod">
                    <set field="dayActivationFromDate" from="partyActivation.fromDate.toInstant() &lt;
                        dayList[daysIndex].dateTime.toInstant() ? dayList[daysIndex].dateTime.toInstant() :
                        partyActivation.fromDate.toInstant()"/>
                    <set field="dayActivationThruDate" from="partyActivationThruDate.toInstant() &gt;
                        dayList[daysIndex].dateTime.plusDays(1).toInstant() ? dayList[daysIndex].dateTime.plusDays(1).toInstant() :
                        partyActivationThruDate.toInstant()"/>

                    <set field="dayActivationAmount" from="Duration.between(dayActivationFromDate,dayActivationThruDate).toMillis()"/>
                    <if condition="dayActivationAmount &lt; 0"><set field="dayActivationAmount" from="0L"/>
                        <log level="warn" message="Amount of milliseconds between activation from and thru dates is negative"/></if>
                    <set field="dayList[daysIndex].amount" from="dayList[daysIndex].amount+dayActivationAmount"/>

<!--                    <log level="warn" message="calculate#PartyActivationUsage dayList[daysIndex] ${dayList[daysIndex]} partyActivationThruDate.toInstant() ${partyActivationThruDate.toInstant()} dayList[daysIndex].dateTime.plusDays(1).toInstant() ${dayList[daysIndex].dateTime.plusDays(1).toInstant()}"/>-->
                    <if condition="partyActivationThruDate.toInstant() &gt; dayList[daysIndex].dateTime.plusDays(1).toInstant()"><then>
                        <set field="daysIndex" from="daysIndex + 1"/>
                    </then><else>
                        <break/>
                    </else></if>
                </while>
            </iterate>

            <!-- Count the number of days that the organization was active for at least minActivationMinutesPerDay minutes-->
            <set field="dayCount" from="dayList.sum{it.amount &gt;=
                minActivationMinutesPerDay * 60.0 * 1000.0 ? 1.0 : 0.0}" type="BigDecimal"/>
            <!-- Check if 0 and set to 1 to avoid division error -->
            <set field="totalDays" from="daysBetweenPeriod!=0?daysBetweenPeriod:1" type="BigDecimal"/>
            <set field="activationPeriodCount" from="dayCount / totalDays" type="BigDecimal"/>

            <set field="dayAmountList" from="dayList*.amount"/>

<!--            <log level="warn" message="calculate#PartyActivationUsage context.toString() ${context.toString()}"/>-->
        </actions>
    </service>
    <service verb="withdraw" noun="FinancialAccountCreditsMonthly" authenticate="anonymous-all">
        <description>This service should run monthly on the first day of the month.

            This service withdraws FinancialAccount Credits from each organization that has had any activation of
            premium features from the PartyActivation records.</description>
        <in-parameters>
            <parameter name="finAccountTypeId" required="true" default-value="OrganizationMonthCredit"/>
            <parameter name="serviceStartTime" type="Timestamp" default="ec.user.nowTimestamp" required="true"/>
        </in-parameters>
        <actions>
            <set field="periodThruDate" from="serviceStartTime"/>
            <set field="periodFromDate" from="new Timestamp(ZonedDateTime.ofInstant(Instant.ofEpochMilli(
                (long) periodThruDate.time), ZoneId.systemDefault()).minusMonths(1).toInstant().toEpochMilli())"/>

            <entity-find entity-name="mantle.account.financial.FinancialAccount" list="financialAccountList" distinct="true">
                <econdition field-name="finAccountTypeId"/>
                <econdition field-name="statusId" value="FaActive"/>
                <date-filter/>
                <select-field field-name="ownerPartyId,finAccountId,availableBalance"/>
            </entity-find>
            <!-- if there are multiple financial accounts for an organization, then remove all but the one with the most credits -->
            <set field="financialAccountList" from="financialAccountList.groupBy{it.ownerPartyId}.collect{it.value.max{it.availableBalance}}"/>

            <iterate list="financialAccountList" entry="financialAccount">
                <set field="totalCreditsUsed" from="0.0" type="BigDecimal"/>
                <entity-find entity-name="mantle.party.Party" list="organizationList">
                    <econdition field-name="partyTypeEnumId" value="PtyOrganization"/>
                    <econdition field-name="disabled" value="N" or-null="true"/>
                    <econdition field-name="ownerPartyId" from="financialAccount.ownerPartyId"/>
                </entity-find>
                <if condition="organizationList.size() == 0">
                    <log level="warn" message="No organization found with financial account for ${financialAccount.ownerPartyId}"/>
                    <continue/></if>
                <iterate list="organizationList" entry="organization">
                    <service-call name="coarchy.CoarchyServices.calculate#PartyActivationUsage" in-map="[organizationPartyId:
                        organization.partyId, periodFromDate:periodFromDate, periodThruDate:periodThruDate]" out-map="context"/>

<!--                    <log level="warn" message="withdraw#FinancialAccountCredits organization ${organization} activationPeriodCount ${activationPeriodCount}"/>-->
                    <set field="totalCreditsUsed" from="totalCreditsUsed + activationPeriodCount" type="BigDecimal"/>
                    <log level="info" message="withdraw dayAmountList ${dayAmountList}"/>
                    <log level="info" message="withdraw ${activationPeriodCount} for ${dayCount} / ${totalDays} days from financialAccount ${financialAccount} for organization ${organization.partyId} owned by ${financialAccount.ownerPartyId}"/>
                </iterate>

                <if condition="totalCreditsUsed &gt; 0.0">
                    <service-call name="mantle.account.FinancialAccountServices.withdraw#FinancialAccount" in-map="[
                        finAccountId:financialAccount.finAccountId,amount:totalCreditsUsed,decimalDigits:4]"
                        out-map="context"/>
                </if>

            </iterate>
<!--                <log level="warn" message="withdraw#FinancialAccountCredits context.toString() ${context.toString()}"/>-->
        </actions>
    </service>
    <service verb="check" noun="PartyActivation" authenticate="anonymous-all">
        <in-parameters>
            <parameter name="userPartyId" required="true"/>
            <parameter name="finAccountTypeId" required="true" default-value="OrganizationMonthCredit"/>
            <parameter name="currentTimestamp" default="ec.user.nowTimestamp" type="Timestamp" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="organizationChangeList" type="List"/>
            <parameter name="needsCredits" type="Boolean"/>
            <parameter name="creditsNeeded" type="Integer"/>
            <parameter name="totalCreditsUsed" type="BigDecimal"/>
            <parameter name="periodFromDate" type="Timestamp"/>
            <parameter name="periodThruDate" type="Timestamp"/>
            <parameter name="activationThruDate" type="Timestamp"/>
        </out-parameters>
        <actions>
            <set field="activationThruDate" from="new Timestamp(ZonedDateTime.ofInstant(Instant.ofEpochMilli(
                (long) currentTimestamp.time), ZoneId.systemDefault()).plusDays(1).toInstant().toEpochMilli())"/>
            <set field="periodFromDate" from="new Timestamp(ZonedDateTime.ofInstant(Instant.ofEpochMilli(
                (long) currentTimestamp.time), ZoneId.systemDefault()).withDayOfMonth(1).toInstant().toEpochMilli())"/>
            <set field="periodThruDate" from="new Timestamp(ZonedDateTime.ofInstant(Instant.ofEpochMilli(
                (long) currentTimestamp.time), ZoneId.systemDefault()).plusMonths(1).withDayOfMonth(1).toInstant().toEpochMilli())"/>

            <!-- check party exists -->
            <entity-find-one entity-name="mantle.party.Party" value-field="userParty">
                <field-map field-name="partyId" from="userPartyId" />
            </entity-find-one>
            <if condition="!userPartyId"><return type="warning" message="Party ${userParty} was not found"/></if>

            <entity-find entity-name="mantle.account.financial.FinancialAccount" list="financialAccountList" distinct="true">
                <econdition field-name="ownerPartyId" from="userPartyId"/>
                <econdition field-name="finAccountTypeId"/>
                <econdition field-name="statusId" value="FaActive"/>
                <date-filter valid-date="currentTimestamp"/>
                <select-field field-name="ownerPartyId,finAccountId,availableBalance"/>
            </entity-find>
<!--            <log level="warn" message="check#PartyActivation financialAccountList ${financialAccountList}"/>-->
            <if condition="financialAccountList.size() == 0">
                <set field="needsCredits" from="true"/>
                <set field="creditsNeeded" from="1" type="Integer"/>
                <return/>
            </if>

            <!-- if there are multiple financial accounts for an organization, then remove all but the one with the most credits -->
            <set field="financialAccount" from="financialAccountList.groupBy{it.ownerPartyId}.collect{it.value.max{it.availableBalance}}[0]"/>

            <set field="organizationChangeList" from="[]"/>
            <set field="totalCreditsUsed" from="0.0" type="BigDecimal"/>
            <entity-find entity-name="mantle.party.Party" list="organizationList">
                <econdition field-name="partyTypeEnumId" value="PtyOrganization"/>
                <econdition field-name="disabled" value="N" or-null="true"/>
                <econdition field-name="ownerPartyId" from="userPartyId"/>
            </entity-find>
            <if condition="organizationList.size() == 0">
                <set field="needsCredits" from="true"/>
                <set field="creditsNeeded" from="1" type="Integer"/>
                <return/>
            </if>
            <iterate list="organizationList" entry="organization">
                <service-call name="coarchy.CoarchyServices.calculate#PartyActivationUsage" in-map="[
                    organizationPartyId:organization.partyId, periodFromDate:periodFromDate, periodThruDate:periodThruDate,
                    activationThruDate:activationThruDate]" out-map="context"/>

                <set field="organizationChangeList" from="organizationChangeList + [organizationId:organization.partyId,activationPeriodCount:activationPeriodCount]"/>
                <!--                    <log level="warn" message="check#PartyActivation organization ${organization} activationPeriodCount ${activationPeriodCount}"/>-->
                <set field="totalCreditsUsed" from="totalCreditsUsed + activationPeriodCount" type="BigDecimal"/>
            </iterate>

<!--            <entity-find-count entity-name="mantle.party.PartyActivationAndParty" count-field="activatedOrganizationCount">-->
<!--                <econdition field-name="ownerPartyId" from="organization.ownerPartyId"/>-->
<!--                <date-filter/></entity-find-count>-->
<!--            <log level="warn" message="check#PartyActivation activatedOrganizationCount ${activatedOrganizationCount} totalCreditsUsed ${totalCreditsUsed} financialAccount.availableBalance ${financialAccount.availableBalance}"/>-->
            <set field="creditsNeeded" from="0.0" type="BigDecimal"/>
            <set field="needsCredits" from="false"/>
            <if condition="totalCreditsUsed &gt;= financialAccount.availableBalance">
                <set field="needsCredits" from="true"/>

                <set field="creditsNeededMax" from="(totalCreditsUsed-financialAccount.availableBalance).setScale(0, BigDecimal.ROUND_UP)" type="Integer"/>
                <set field="creditsNeeded" from="creditsNeededMax&gt;1.0?creditsNeededMax:1"/>
            </if>

<!--            <log level="warn" message="check#PartyActivation context.toString() ${context.toString()}"/>-->
        </actions>
    </service>
    <service verb="check" noun="PartyActivationDaily" authenticate="anonymous-all">
        <in-parameters>
            <parameter name="finAccountTypeId" required="true" default-value="OrganizationMonthCredit"/>
            <parameter name="currentTimestamp" default="ec.user.nowTimestamp" type="Timestamp" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="organizationChangeList" type="List"/>
            <parameter name="ownerChangeList" type="List"/>
            <parameter name="periodFromDate" type="Timestamp"/>
            <parameter name="periodThruDate" type="Timestamp"/>
            <parameter name="activationThruDate" type="Timestamp"/>
        </out-parameters>
        <actions>
            <set field="activationThruDate" from="new Timestamp(ZonedDateTime.ofInstant(Instant.ofEpochMilli(
                (long) currentTimestamp.time), ZoneId.systemDefault()).plusDays(1).toInstant().toEpochMilli())"/>
            <set field="periodFromDate" from="new Timestamp(ZonedDateTime.ofInstant(Instant.ofEpochMilli(
                (long) currentTimestamp.time), ZoneId.systemDefault()).withDayOfMonth(1).toInstant().toEpochMilli())"/>
            <set field="periodThruDate" from="new Timestamp(ZonedDateTime.ofInstant(Instant.ofEpochMilli(
                (long) currentTimestamp.time), ZoneId.systemDefault()).plusMonths(1).withDayOfMonth(1).toInstant().toEpochMilli())"/>

            <entity-find entity-name="mantle.account.financial.FinancialAccount" list="financialAccountList" distinct="true">
                <econdition field-name="finAccountTypeId"/>
                <econdition field-name="statusId" value="FaActive"/>
                <date-filter valid-date="currentTimestamp"/>
                <select-field field-name="ownerPartyId,finAccountId,availableBalance"/>
            </entity-find>
            <!-- if there are multiple financial accounts for an organization, then remove all but the one with the most credits -->
            <set field="financialAccountList" from="financialAccountList.groupBy{it.ownerPartyId}.collect{it.value.max{it.availableBalance}}"/>

            <set field="organizationChangeList" from="[]"/>
            <set field="ownerChangeList" from="[]"/>
            <iterate list="financialAccountList" entry="financialAccount">
                <set field="totalCreditsUsed" from="0.0" type="BigDecimal"/>
                <entity-find entity-name="mantle.party.Party" list="organizationList">
                    <econdition field-name="partyTypeEnumId" value="PtyOrganization"/>
                    <econdition field-name="disabled" value="N" or-null="true"/>
                    <econdition field-name="ownerPartyId" from="financialAccount.ownerPartyId"/>
                </entity-find>
                <if condition="organizationList.size() == 0">
                    <log level="warn" message="No organization found with financial account for ${financialAccount.ownerPartyId}"/>
                    <continue/></if>
                <iterate list="organizationList" entry="organization">
                    <service-call name="coarchy.CoarchyServices.calculate#PartyActivationUsage" in-map="[organizationPartyId:
                        organization.partyId, periodFromDate:periodFromDate, periodThruDate:periodThruDate,
                        activationThruDate:activationThruDate]" out-map="context"/>

                    <!--                    <log level="warn" message="check#PartyActivationDaily organization ${organization} activationPeriodCount ${activationPeriodCount}"/>-->
                    <set field="organizationChangeList" from="organizationChangeList + [organizationId:organization.partyId,activationPeriodCount:activationPeriodCount,deactivated:'N']"/>
                    <set field="totalCreditsUsed" from="totalCreditsUsed + activationPeriodCount" type="BigDecimal"/>
                </iterate>
                <set field="ownerChangeList" from="ownerChangeList + [ownerPartyId:financialAccount.ownerPartyId,totalCreditsUsed:totalCreditsUsed,availableBalance:financialAccount.availableBalance]"/>

<!--                <log level="warn" message="check#PartyActivationDaily organizationList.size() ${organizationList.size()} totalCreditsUsed ${totalCreditsUsed} financialAccount.availableBalance ${financialAccount.availableBalance}"/>-->
                <if condition="totalCreditsUsed &gt; 0.0 &amp;&amp; totalCreditsUsed &gt; financialAccount.availableBalance">
                    <log message="${financialAccount.ownerPartyId} used ${totalCreditsUsed} / ${financialAccount.availableBalance} credits this month for organizations ${organizationList*.partyId}. Deactivating all of the organizations."/>
                    <iterate list="organizationList" entry="organization">
                        <entity-find entity-name="mantle.party.PartyActivation" list="partyActivationList" limit="1" for-update="true">
                            <econdition field-name="partyId" from="organization.partyId"/>
                            <date-filter valid-date="currentTimestamp"/>
                            <order-by field-name="-fromDate"/>
                        </entity-find>
                        <if condition="partyActivationList.size() == 0">
<!--                            <log level="warn" message="No PartyActivation found for ${organization.partyId}"/>-->
                            <continue/></if>

<!--                        <log level="warn" message="check#PartyActivationDaily partyActivationList ${partyActivationList}"/>-->
                        <set field="organizationChangeList.find{it.organizationId == organization.partyId}.deactivated" value="Y"/>

                        <set field="partyActivationList.getFirst().thruDate" from="currentTimestamp"/>
                        <entity-update value-field="partyActivationList.getFirst()"/>
                    </iterate>
                </if>
            </iterate>
<!--            <log level="warn" message="check#PartyActivationDaily context.toString() ${context.toString()}"/>-->
        </actions>
    </service>

    <service verb="get" noun="CloneOrganizationList">
        <in-parameters>
            <parameter name="term"/>
        </in-parameters>
        <out-parameters>
            <parameter name="outList"/>
        </out-parameters>
        <actions>
            <entity-find entity-name="mantle.party.PartyToAndRelationship" list="organizationList" distinct="true">
                <date-filter/>
                <econdition field-name="relationshipTypeEnumId" value="PrtMember"/>
                <econdition field-name="toRoleTypeId" value="OrgInternal"/>
                <econdition field-name="fromPartyId" from="ec.user.userAccount.partyId"/>
                <!--                <select-field field-name="toPartyId,ownerPartyId,organizationName,visibilityEnumId"/>-->
                <order-by field-name="organizationName"/></entity-find>
            <set field="outList" from="[]"/>
            <iterate list="organizationList" entry="organization">
                <entity-find-count entity-name="mantle.party.PartyActivation" count-field="partyActivationCount">
                    <econdition field-name="partyId" from="organization.toPartyId"/>
                    <date-filter/></entity-find-count>
                <set field="ec.user.context?.activeOrgId" from="organization.toPartyId"/>
                <set field="ec.user.context?.filterOrgIds" from="[organization.toPartyId]"/>
                <entity-find-count entity-name="coarchy.ProcessStoryActivity" count-field="processStoryActivityCount"/>
                <if condition="partyActivationCount &gt; 0 &amp;&amp; processStoryActivityCount &gt; 0">
                    <script>outList.add([value:organization.toPartyId, label:organization.organizationName])</script>
                </if>
<!--                <log level="warn" message="getCloneOrganizationList context.toString() ${context.toString()}"/>-->
            </iterate>
<!--            <log level="warn" message="getCloneOrganizationList context.toString() ${context.toString()}"/>-->
        </actions>
    </service>
    <service verb="get" noun="ProcessStoryList">
        <description>Internal service needs validation that user can access organizationId</description>
        <in-parameters>
            <parameter name="organizationId" required="true"/>
            <parameter name="term"/>
        </in-parameters>
        <out-parameters>
            <parameter name="outList"/>
        </out-parameters>
        <actions>
            <set field="ec.user.context?.activeOrgId" from="organizationId"/>
            <set field="ec.user.context?.filterOrgIds" from="[organizationId]"/>
            <if condition="!term"><then>
                <entity-find entity-name="coarchy.ProcessStory" list="processStoryList">
                    <econdition field-name="organizationId"/>
                    <order-by field-name="name"/></entity-find>
            </then><else>
                <entity-find entity-name="coarchy.ProcessStory" list="processStoryList">
                    <econdition field-name="organizationId"/>
                    <econdition field-name="name" operator="like" value="%${term}%" ignore-case="true"/>
                    <order-by field-name="name"/></entity-find>
            </else></if>

            <set field="outList" from="[]"/>
            <script>
                for (def story in processStoryList)
                    outList.add([value:story?.processStoryId, label:story?.name])
            </script>
<!--            <log level="warn" message="getProcessStoryList context.toString() ${context.toString()}"/>-->
        </actions>
    </service>
    <service verb="get" noun="ActivityList">
        <description>Internal service needs validation that user can access organizationId</description>
        <in-parameters>
            <parameter name="processStoryId" required="true"/>
            <parameter name="organizationId" required="true"/>
            <parameter name="term"/>
        </in-parameters>
        <out-parameters>
            <parameter name="outList" type="List"/>
        </out-parameters>
        <actions>
            <set field="ec.user.context?.activeOrgId" from="organizationId"/>
            <set field="ec.user.context?.filterOrgIds" from="[organizationId]"/>
            <set field="activityList" from="[]"/>
            <if condition="!term"><then>
                <entity-find entity-name="coarchy.ProcessStoryActivityDetail" list="activityList">
                    <econdition field-name="processStoryId"/>
                    <econdition field-name="action" operator="is-not-null"/>
                    <!--                    <econdition field-name="storyActivityOrganizationId" from="organizationId"/>-->
                    <!--                    <econdition field-name="activityOrganizationId" from="organizationId"/>-->
                    <!--                    <econdition field-name="storyOrganizationId" from="organizationId"/>-->
                    <select-field field-name="activityId,condition,action"/>
                    <order-by field-name="sequenceNum"/></entity-find>
            </then><else>
                <!-- TODO: Also find by actor name -->
                <entity-find entity-name="coarchy.ProcessStoryActivityDetail" list="activityList">
                    <econdition field-name="processStoryId"/>
                    <econdition field-name="action" operator="is-not-null"/>
                    <!--                    <econdition field-name="storyActivityOrganizationId" from="organizationId"/>-->
                    <!--                    <econdition field-name="activityOrganizationId" from="organizationId"/>-->
                    <!--                    <econdition field-name="storyOrganizationId" from="organizationId"/>-->
                    <econditions combine="or">
                        <econdition field-name="condition" operator="like" value="%${term}%" ignore-case="true"/>
                        <econdition field-name="action" operator="like" value="%${term}%" ignore-case="true"/>
                    </econditions>
                    <select-field field-name="activityId,condition,action"/>
                    <order-by field-name="sequenceNum"/></entity-find>
            </else></if>
<!--            <log level="warn" message="getActivityList context.toString() ${context.toString()}"/>-->
            <set field="outList" from="[]"/>
            <iterate list="activityList" entry="activity">
                <entity-find entity-name="coarchy.ActivityActorDetail" list="activityActorList">
                    <econdition field-name="activityId" from="activity.activityId"/>
                    <order-by field-name="name"/></entity-find>
                <set field="processStoryActivity" from="activity.getMap() + [actorNames:activityActorList*.name]"/>
                <set field="label" from="ec.resource.template('component://coarchy/template/Activity.html.ftl', '.ftl')"/>
                <script>outList.add([value:activity?.activityId, label:"${label.size()&gt;97?label.take(97)+'...':label}"])</script>
            </iterate>
            <!--            <log level="warn" message="getActivityList context.toString() ${context.toString()}"/>-->
        </actions>
    </service>
    <service verb="move" noun="Activities">
        <description>Internal service needs validation that user can access organizationId</description>
        <in-parameters>
            <parameter name="activityId" required="true"/>
            <parameter name="moveType" required="true"/>
            <parameter name="organizationId" required="true"/>
            <parameter name="processStoryId" required="true"/>
            <parameter name="insertActivityId"/>
            <parameter name="insertType" required="true"/>
            <parameter name="activityIdNum" required="true" type="Integer"/>
        </in-parameters>
        <out-parameters>
            <parameter name="pageIndex"/>
            <parameter name="activityId"/>
            <parameter name="clipboardEntryId"/>
        </out-parameters>
        <actions>
            <if condition="ec.user.context?.activityIdList==null">
                <set field="ec.user.context.activityIdList" from="[]"/>
            </if>
            <set field="ec.user.context.activityIdList" from="ec.user.context.activityIdList + [activityId]"/>
            <set field="activityIdList" from="ec.user.context.activityIdList"/>

<!--            <log level="warn" message="copy#Activities context.toString() ${context.toString()} activityIdList.size() ${activityIdList.size()}"/>-->
            <if condition="activityIdList.size() == activityIdNum.toInteger()">
                <entity-find entity-name="coarchy.ProcessStoryActivityDetail" list="originalProcessStoryActivityList" distinct="true">
                    <econdition field-name="activityId" operator="in" from="activityIdList"/>
                    <!-- Don't select fields from activityactor (actorId) -->
                    <select-field field-name="processStoryActivityId,sequenceNum,detailProcessStoryId,action,condition,activityId,implementationId"/>
                    <order-by field-name="sequenceNum"/>
                </entity-find>
                <set field="activeOrgId" from="ec.user.context?.activeOrgId"/>
                <set field="ec.user.context?.activeOrgId" from="organizationId"/>
                <set field="ec.user.context?.filterOrgIds" from="[organizationId]"/>

                <entity-find entity-name="coarchy.ProcessStoryActivityDetail" list="insertProcessStoryActivityList" distinct="true" limit="1">
                    <econdition field-name="activityId" from="insertActivityId"/>
                    <!-- Don't select fields from activityactor (actorId) -->
                    <select-field field-name="processStoryActivityId,sequenceNum,detailProcessStoryId,action,condition,activityId,implementationId"/>
                    <order-by field-name="sequenceNum"/>
                </entity-find>
                <set field="insertActivity" from="insertProcessStoryActivityList?.getFirst()"/>

                <set field="insertSequenceNum" from="insertActivity?.sequenceNum?:0"/>
                <if condition="insertType=='below'">
                    <set field="pageIndex" from="downPageIndex"/>
                    <entity-find entity-name="coarchy.ProcessStoryActivityDetail" list="processStoryActivityMaxList" limit="1">
                        <econdition field-name="processStoryId"/>
                        <econdition field-name="sequenceNum" operator="greater" from="insertActivity?.sequenceNum?.toInteger()" ignore="!insertActivity"/>
                        <select-field field-name="processStoryActivityId,sequenceNum"/>
                        <order-by field-name="sequenceNum"/></entity-find>
                    <!-- This might be null, but if it is null then the right behavior will happen anyways -->
                    <set field="insertSequenceNum" from="processStoryActivityMaxList?.getFirst()?.sequenceNum?:(insertSequenceNum?:0)"/>
                </if>
                <entity-find entity-name="coarchy.ProcessStoryActivityDetail" list="processStoryActivityList">
                    <econdition field-name="processStoryId"/>
                    <econdition field-name="sequenceNum" operator="greater-equals" from="insertSequenceNum?.toInteger()" ignore-if-empty="true"/>
                    <select-field field-name="processStoryActivityId,sequenceNum,activityId"/>
                    <order-by field-name="-sequenceNum"/></entity-find>
                <iterate list="processStoryActivityList" entry="processStoryActivity">
                    <service-call name="update#coarchy.ProcessStoryActivity" in-map="[processStoryActivityId:
                            processStoryActivity.processStoryActivityId,sequenceNum:
                            processStoryActivity.sequenceNum+originalProcessStoryActivityList.size()]"/>
                </iterate>

                <set field="actorIdMap" from="[:]"/>
                <if condition="organizationId!=activeOrgId">
                    <set field="ec.user.context?.activeOrgId" from="activeOrgId"/>
                    <set field="ec.user.context?.filterOrgIds" from="[activeOrgId]"/>
                </if>
                <entity-find entity-name="coarchy.ActivityActorDetail" list="activityActorList" distinct="true">
                    <econdition field-name="activityId" from="originalProcessStoryActivityList*.activityId"/>
                    <select-field field-name="actorId,activityId,name,description"/>
                    <order-by field-name="name"/></entity-find>
                <if condition="organizationId!=activeOrgId">
                    <set field="ec.user.context?.activeOrgId" from="organizationId"/>
                    <set field="ec.user.context?.filterOrgIds" from="[organizationId]"/>
                </if>
                <iterate list="activityActorList" entry="activityActor">
                    <entity-find entity-name="coarchy.ActivityActorDetail" list="insideActivityActorList" distinct="true" limit="1">
                        <econdition field-name="name" from="activityActor.name" ignore-case="true"/>
                        <select-field field-name="actorId,name"/>
                        <order-by field-name="name"/></entity-find>
                    <if condition="!insideActivityActorList"><then>
                        <if condition="!actorIdMap.keys?.contains(activityActor.actorId)">
                            <service-call name="create#coarchy.Actor" in-map="[name:activityActor.name,
                                description:activityActor.description,organizationId:organizationId]" out-map="actorContext"/>
                            <script>actorIdMap.put(activityActor.actorId,actorContext.actorId)</script>
                        </if>
                    </then><else>
                        <script>actorIdMap.put(activityActor.actorId,insideActivityActorList.getFirst().actorId)</script>
                    </else></if>
                </iterate>
<!--                <log level="warn" message="copy#Activities actorIdMap ${actorIdMap}"/>-->

                <iterate list="originalProcessStoryActivityList" entry="activity">
                    <set field="actorIdList" from="activityActorList.findAll{ it.activityId == activity.activityId }*.actorId"/>
<!--                    <log level="warn" message="copy#Activities actorIdList ${actorIdList}"/>-->
                    <if condition="organizationId==activeOrgId"><then>
                    </then><else>
                        <set field="actorIdList" from="actorIdList.collect{ actorIdMap[it] }"/>
<!--                        <log level="warn" message="copy#Activities diff org actorIdList ${actorIdList}"/>-->
                    </else></if>
                    <service-call name="coarchy.CoarchyServices.create#Activity" in-map="[processStoryId:processStoryId,organizationId:organizationId,condition:activity.condition,action:activity.action,actorIdList:actorIdList,sequenceNum:insertSequenceNum+activity_index,implementationId:activity.implementationId,ignoreNoAction:true]"/>
<!--                    <log level="warn" message="copy#Activities activityActorList ${activityActorList}"/>-->
                </iterate>

                <if condition="moveType=='cut'">
                    <iterate list="activityIdList" entry="activityId">
                        <set field="ec.user.context?.activeOrgId" from="activeOrgId"/>
                        <set field="ec.user.context?.filterOrgIds" from="[activeOrgId]"/>

                        <!--                        <log level="warn" message="copy#Activities moveType ${moveType} processStoryActivity.activityId ${processStoryActivity.activityId}"/>-->
                        <service-call name="coarchy.CoarchyServices.delete#Activity" in-map="[activityId:activityId]"/>
                        <set field="ec.user.context?.activeOrgId" from="organizationId"/>
                        <set field="ec.user.context?.filterOrgIds" from="[organizationId]"/>
                    </iterate>
                </if>

                <service-call name="org.moqui.impl.UserServices.set#Preference" in-map="[preferenceKey:'ACTIVE_ORGANIZATION',preferenceValue:organizationId]"/>
<!--                <log level="warn" message="copy#Activities context.toString() ${context.toString()}"/>-->
            </if>
        </actions>
    </service>
    <service verb="copy" noun="Activities">
        <in-parameters>
            <parameter name="activityId" required="true"/>
            <parameter name="moveTypeEnumId" required="true"/>
            <parameter name="activityIdNum" required="true" type="Integer"/>
        </in-parameters>
        <out-parameters>
            <parameter name="activityId"/>
            <parameter name="clipboardEntryId"/>
        </out-parameters>
        <actions>
            <if condition="!ec.user.context?.clipboardEntryId">
<!--                <log level="warn" message="ec.user.context.activeOrgId ${ec.user.context.activeOrgId}"/>-->
                <entity-find-count entity-name="moqui.basic.Enumeration" count-field="enumCount">
                    <econdition field-name="enumTypeId" value="ClipboardMoveType"/>
                    <econdition field-name="enumId" from="moveTypeEnumId"/></entity-find-count>
                <if condition="enumCount == 0"><return type="danger" error="true" public="true"
                        message="Invalid moveTypeEnumId ${moveTypeEnumId}"/></if>

                <entity-find entity-name="coarchy.ClipboardEntry" list="entryList">
                    <econdition field-name="partyId" from="ec.user.userAccount?.partyId"/>
                    <order-by field-name="-entryDate"/></entity-find>
                <iterate list="entryList" entry="entry">
                    <if condition="entry_index &gt;= 4">
<!--                        <log level="warn" message="copy#Activities deleting old clipboard entry ${entry} ${entry_index}"/>-->
                        <entity-find entity-name="coarchy.ClipboardActor" list="actorList">
                            <econdition field-name="clipboardEntryId" from="entry.clipboardEntryId"/>
                            <order-by field-name="actorSeqId"/></entity-find>
                        <iterate list="actorList" entry="actor">
                            <service-call name="delete#coarchy.ClipboardActor" in-map="[clipboardEntryId:entry.clipboardEntryId,
                                actorSeqId:actor.actorSeqId]"/>
                        </iterate>
                        <entity-find entity-name="coarchy.ClipboardActivity" list="activityList">
                            <econdition field-name="clipboardEntryId" from="entry.clipboardEntryId"/>
                            <order-by field-name="activitySeqId"/></entity-find>
                        <iterate list="activityList" entry="activity">
                            <service-call name="delete#coarchy.ClipboardActivity" in-map="[clipboardEntryId:entry.clipboardEntryId,
                                activitySeqId:activity.activitySeqId]"/>
                        </iterate>
                        <service-call name="delete#coarchy.ClipboardEntry" in-map="[clipboardEntryId:entry.clipboardEntryId]"/>
                    </if>
                </iterate>

                <service-call name="create#coarchy.ClipboardEntry" in-map="[partyId:ec.user.userAccount?.partyId,
                    fromOrganizationId:ec.user.context?.activeOrgId,moveTypeEnumId:moveTypeEnumId,entryDate:
                    ec.user.nowTimestamp]" out-map="context"/>
                <set field="ec.user.context.clipboardEntryId" from="clipboardEntryId"/>
            </if>
            <if condition="ec.user.context?.activityIdList==null">
                <set field="ec.user.context.activityIdList" from="[]"/>
            </if>
            <set field="ec.user.context.activityIdList" from="ec.user.context.activityIdList + [activityId]"/>
            <set field="activityIdList" from="ec.user.context.activityIdList"/>

            <set field="clipboardEntryId" from="ec.user.context.clipboardEntryId"/>
            <entity-find-one entity-name="coarchy.Activity" value-field="activity" auto-field-map="[activityId:activityId]"/>
            <service-call name="create#coarchy.ClipboardActivity" in-map="[clipboardEntryId:clipboardEntryId,
                condition:activity.condition,action:activity.action,implementationId:activity.implementationId]" out-map="activityOut"/>
            <entity-find entity-name="ActivityActorDetail" list="actorList" distinct="true">
                <econdition field-name="activityId"/>
                <select-field field-name="actorId,activityId,name,description"/></entity-find>
<!--            <log level="warn" message="activityId ${activityId}"/>-->
            <iterate list="actorList" entry="actor">
<!--                <log level="warn" message="clipboardEntryId ${clipboardEntryId} actor ${actor} actor.actorId ${actor.actorId}"/>-->
                <service-call name="create#coarchy.ClipboardActor" in-map="[clipboardEntryId:clipboardEntryId,
                    activitySeqId:activityOut.activitySeqId,name:actor.name,description:actor.description]"/>
            </iterate>

            <if condition="moveTypeEnumId=='CbmtCut' &amp;&amp; activityIdList.size() == activityIdNum.toInteger()">
                <iterate list="activityIdList" entry="activityId">
                    <service-call name="coarchy.CoarchyServices.delete#Activity" in-map="[activityId:activityId]"/>
                </iterate>
            </if>

<!--                        <log level="warn" message="copy#Activities context.toString() ${context.toString()}"/>-->
        </actions>
    </service>
    <!-- TODO: Improve the index handling on multiple activities inserted -->
    <service verb="paste" noun="Activities">
        <in-parameters>
            <parameter name="clipboardEntryId" required="true"/>
            <parameter name="pageIndex" required="true"/>
            <parameter name="downPageIndex" required="true"/>
            <parameter name="processStoryId" required="true"/>
            <parameter name="sequenceNum" required="true"/>
            <parameter name="organizationId" required="true"/>
            <parameter name="insertType" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="pageIndex"/>
        </out-parameters>
        <actions>
            <entity-find entity-name="coarchy.ClipboardEntry" list="entryList" limit="1">
                <econdition field-name="partyId" from="ec.user.userAccount?.partyId"/>
                <econdition field-name="clipboardEntryId"/>
            </entity-find>
            <if condition="entryList.size() == 0"><return type="error" message="No clipboard entry found"/></if>
            <entity-find-count entity-name="mantle.party.PartyRelationship" count-field="partyRelationshipCount">
                <date-filter/>
                <econdition field-name="relationshipTypeEnumId" value="PrtMember"/>
                <econdition field-name="toRoleTypeId" value="OrgInternal"/>
                <econdition field-name="fromPartyId" from="ec.user.userAccount.partyId"/>
                <econdition field-name="toPartyId" from="organizationId"/></entity-find-count>
            <if condition="partyRelationshipCount == 0"><return type="error" message="User is not a member of organization"/></if>

            <set field="entry" from="entryList.getFirst()"/>
            <set field="moveTypeEnumId" from="entry.moveTypeEnumId"/>
            <set field="clipboardEntryId" from="entry.clipboardEntryId"/>
            <entity-find entity-name="coarchy.ClipboardActivity" list="activityList">
                <econdition field-name="clipboardEntryId"/>
                <order-by field-name="activitySeqId"/>
            </entity-find>
<!--            <log level="warn" message="paste#Activities activityList ${activityList}"/>-->

            <set field="insertSequenceNum" from="sequenceNum"/>
            <if condition="insertType=='below'">
                <set field="pageIndex" from="downPageIndex"/>
                <entity-find entity-name="coarchy.ProcessStoryActivityDetail" list="processStoryActivityMaxList" limit="1">
                    <econdition field-name="processStoryId"/>
                    <econdition field-name="sequenceNum" operator="greater" from="sequenceNum.toInteger()"/>
                    <select-field field-name="processStoryActivityId,sequenceNum"/>
                    <order-by field-name="sequenceNum"/></entity-find>
                <!-- This might be null, but if it is null then the right behavior will happen anyways -->
                <set field="insertSequenceNum" from="processStoryActivityMaxList?.getFirst()?.sequenceNum!=null?
                    processStoryActivityMaxList?.getFirst()?.sequenceNum:sequenceNum.toInteger()+1"/>
            </if>
            <entity-find entity-name="coarchy.ProcessStoryActivityDetail" list="processStoryActivityList">
                <econdition field-name="processStoryId"/>
                <econdition field-name="sequenceNum" operator="greater-equals" from="insertSequenceNum.toInteger()"/>
                <select-field field-name="processStoryActivityId,sequenceNum,activityId"/>
                <order-by field-name="-sequenceNum"/></entity-find>
            <iterate list="processStoryActivityList" entry="processStoryActivity">
                <service-call name="update#coarchy.ProcessStoryActivity" in-map="[
                    processStoryActivityId:processStoryActivity.processStoryActivityId,
                    sequenceNum:processStoryActivity.sequenceNum.toInteger()+activityList.size()]"/>
            </iterate>

            <set field="actorIdMap" from="[:]"/>
            <entity-find entity-name="coarchy.ClipboardActor" list="actorList" distinct="true">
                <econdition field-name="clipboardEntryId"/>
                <select-field field-name="actorSeqId,activitySeqId,name,description"/>
                <order-by field-name="actorSeqId"/></entity-find>
            <iterate list="actorList" entry="actor">
                <entity-find entity-name="coarchy.Actor" list="insideActorList" distinct="true" limit="1">
                    <econdition field-name="name" from="actor.name"/>
                    <select-field field-name="actorId,name"/>
                    <order-by field-name="name"/></entity-find>
                <if condition="!insideActorList"><then>
                    <service-call name="create#coarchy.Actor" in-map="[name:actor.name,
                            description:actor.description,organizationId:organizationId]" out-map="actorContext"/>
                    <script>actorIdMap.put(actor.actorSeqId,actorContext?.actorId)</script>
                </then><else>
                    <script>actorIdMap.put(actor.actorSeqId,insideActorList.getFirst().actorId)</script>
                </else></if>
            </iterate>
<!--                <log level="warn" message="copy#Activities actorIdMap ${actorIdMap}"/>-->

            <iterate list="activityList" entry="activity">
                <set field="actorSeqIdList" from="actorList.findAll{ it.activitySeqId == activity.activitySeqId }*.actorSeqId"/>
                <set field="actorIdList" from="actorSeqIdList.collect{ actorIdMap[it] }"/>
                <service-call name="coarchy.CoarchyServices.create#Activity" in-map="[processStoryId:processStoryId,organizationId:organizationId,condition:activity.condition,action:activity.action,actorIdList:actorIdList,sequenceNum:insertSequenceNum.toInteger()+activity_index,implementationId:activity.implementationId,ignoreNoAction:true]"/>
            </iterate>

<!--            <log level="warn" message="paste#Activities context.toString() ${context.toString()}"/>-->
        </actions>
    </service>
    <service verb="delete" noun="Activity">
        <in-parameters>
            <parameter name="activityId" required="true"/>
            <parameter name="processStoryActivityId"/>
            <parameter name="actorIdList" type="List"/>
            <parameter name="pageIndex"/>
        </in-parameters>
        <out-parameters>
            <parameter name="pageIndex"/>
            <parameter name="activityId"/>
        </out-parameters>
        <actions>
            <if condition="!processStoryActivityId">
                <entity-find entity-name="coarchy.ProcessStoryActivity" list="activityList">
                    <econdition field-name="activityId"/>
                </entity-find>
                <if condition="activityList.size() == 0"><return type="danger" error="true" message="No ProcessStoryActivity found for Activity"/></if>
                <if condition="activityList.size() &gt; 1"><return type="info" message="Multiple ProcessStoryActivity found for Activity"/></if>
                <set field="processStoryActivityId" from="activityList.getFirst().processStoryActivityId"/>
            </if>
            <if condition="!actorIdList">
                <entity-find entity-name="coarchy.ActivityActor" list="actorList">
                    <econdition field-name="activityId" from="activityId"/>
                </entity-find>
                <set field="actorIdList" from="actorList*.actorId"/>
            </if>
            <iterate list="actorIdList" entry="actorId">
                <service-call name="delete#coarchy.ActivityActor" in-map="[activityId:activityId, actorId:actorId]"/>
            </iterate>
            <service-call name="delete#coarchy.ProcessStoryActivity" in-map="[processStoryActivityId:processStoryActivityId]"/>
        </actions>
    </service>
    <service verb="insert" noun="Activity">
        <in-parameters>
            <parameter name="pageIndex"/>
            <parameter name="downPageIndex"/>
            <parameter name="processStoryId"/>
            <parameter name="sequenceNum"/>
            <parameter name="implementationId"/>
            <parameter name="condition"/>
            <parameter name="actorIdList"/>
            <parameter name="action"/>
            <parameter name="insertType"/>
            <parameter name="organizationId"/>
            <parameter name="sequenceNumDiff" default="1" type="Integer"/>
        </in-parameters>
        <out-parameters>
            <parameter name="pageIndex"/>
            <parameter name="pageSize"/>
            <parameter name="orderByField"/>
        </out-parameters>
        <actions>
            <if condition="!action"><return type="danger" error="true" message="An action is needed for an activity"/></if>
            <set field="insertSequenceNum" from="sequenceNum"/>
            <if condition="insertType=='below'">
                <set field="pageIndex" from="downPageIndex"/>
                <entity-find entity-name="coarchy.ProcessStoryActivityDetail" list="processStoryActivityMaxList" limit="1">
                    <econdition field-name="sequenceNum" operator="greater" from="sequenceNum.toInteger()"/>
                    <select-field field-name="processStoryActivityId,sequenceNum"/>
                    <order-by field-name="sequenceNum"/></entity-find>
                <!-- This might be null, but if it is null then the right behavior will happen anyways -->
                <set field="insertSequenceNum" from="processStoryActivityMaxList?.getFirst()?.sequenceNum"/>
            </if>

            <entity-find entity-name="coarchy.ProcessStoryActivityDetail" list="processStoryActivityList">
                <econdition field-name="sequenceNum" operator="greater-equals" from="insertSequenceNum.toInteger()"/>
                <select-field field-name="processStoryActivityId,sequenceNum"/>
                <order-by field-name="-sequenceNum"/></entity-find>
            <iterate list="processStoryActivityList" entry="processStoryActivity">
                <service-call name="update#coarchy.ProcessStoryActivity" in-map="[processStoryActivityId:processStoryActivity.processStoryActivityId,sequenceNum:processStoryActivity.sequenceNum.toInteger()+sequenceNumDiff]"/>
            </iterate>
            <service-call name="coarchy.CoarchyServices.create#Activity" in-map="[processStoryId:processStoryId,organizationId:organizationId,condition:condition,actorIdList:actorIdList,action:action,sequenceNum:insertSequenceNum,implementationId:implementationId]"/>
        </actions>
    </service>

    <service verb="get" noun="ClipboardActivityAndCount">
        <in-parameters>
            <parameter name="clipboardEntryId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="activityText"/>
            <parameter name="activityCount"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="coarchy.ClipboardEntry" value-field="clipboardEntry"
                    auto-field-map="[clipboardEntryId:clipboardEntryId,partyId:ec.user.userAccount.partyId]"/>
            <if condition="clipboardEntry==null"><return type="danger" error="true" message="No clipboard entry found"/></if>

            <entity-find entity-name="coarchy.ClipboardActivity" list="activityList" limit="1">
                <econdition field-name="clipboardEntryId"/></entity-find>
            <if condition="activityList.size() == 0"><return type="danger" error="true" message="No clipboard activity found"/></if>
            <set field="processStoryActivity" from="activityList.getFirst().getMap()"/>
            <if condition="processStoryActivity.action"><then>
                <entity-find entity-name="coarchy.ClipboardActor" list="actorList">
                    <econdition field-name="clipboardEntryId"/>
                    <econdition field-name="activitySeqId" from="processStoryActivity.activitySeqId"/>
                    <order-by field-name="name"/></entity-find>
                <set field="processStoryActivity" from="processStoryActivity + [actorNames:actorList*.name]"/>
                <set field="activityText" from="ec.resource.template('component://coarchy/template/Activity.html.ftl', '.ftl')"/>
            </then><else>
                <set field="activityText" value="⏎ Paragraph"/>
            </else></if>
            <entity-find-count entity-name="coarchy.ClipboardActivity" count-field="activityCount">
                <econdition field-name="clipboardEntryId"/></entity-find-count>
<!--            <log level="warn" message="getClipboardActivityAndCount context.toString() ${context.toString()}"/>-->
        </actions>
    </service>

    <service verb="get" noun="OrderProgress">
        <in-parameters>
            <parameter name="orderId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="statusId"/>
            <parameter name="description"/>
        </out-parameters>
        <actions>
            <entity-find entity-name="mantle.order.OrderHeaderAndPart" list="existingOrder1List" limit="1">
                <econdition field-name="orderId"/>
                <econdition field-name="customerPartyId" from="ec.user.userAccount.partyId"/>
                <select-field field-name="orderId,placedDate,completedDate,entryDate,statusId"/>
                <order-by field-name="-entryDate"/><!-- get most recent open order --></entity-find>

            <set field="statusId" from="existingOrder1List.getFirst()?.statusId"/>
            <if condition="statusId==null"><return type="danger" error="true" message="No order found"/></if>
            <entity-find-one entity-name="moqui.basic.StatusItem" value-field="status" auto-field-map="[statusTypeId:'OrderHeader',statusId:statusId]" cache="true"/>
            <set field="description" from="status.description"/>

            <if condition="statusId=='OrderCompleted' &amp;&amp; ec.web.sessionAttributes?.checkoutOrganizationId">
                <set field="checkoutOrganizationId" from="ec.web.sessionAttributes.checkoutOrganizationId"/>
                <script>
                    ec.web.sessionAttributes.remove('checkoutOrganizationId');
                    ec.user.setPreference("ACTIVE_ORGANIZATION", checkoutOrganizationId);
                </script>
                <set field="ec.user.context?.activeOrgId" from="checkoutOrganizationId"/>
                <set field="ec.user.context?.filterOrgIds" from="[checkoutOrganizationId]"/>
                <service-call name="coarchy.CoarchyServices.activateOrDeactivate#Organization" in-map="[organizationPartyId:checkoutOrganizationId]"/>
                <entity-find-one entity-name="mantle.party.Organization" value-field="organization" auto-field-map="[partyId:checkoutOrganizationId]"/>
                <message public="true">Automatically activated Premium Features for ${organization.organizationName}</message>
            </if>

            <!--            <log level="warn" message="get#OrderProgress context.toString() ${context.toString()}"/>-->
        </actions>
    </service>

    <service verb="unsubscribe" noun="ContactList">
        <in-parameters>
            <parameter name="optInVerifyCode" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="statusId"/>
        </out-parameters>
        <actions>
            <entity-find entity-name="mantle.marketing.contact.ContactListParty" list="contactListPartyList" limit="1" for-update="true">
                <econdition field-name="optInVerifyCode" operator="is-not-null"/>
                <econdition field-name="optInVerifyCode"/>
                <date-filter/>
                <order-by field-name="-fromDate"/>
            </entity-find>
            <set field="contactListParty" from="contactListPartyList?.getFirst()"/>

            <if condition="contactListParty &amp;&amp; contactListParty.statusId!='CLPT_UNSUBSCRIBED'"><then>
                <set field="contactListParty.statusId" value="CLPT_UNSUBSCRIBED"/>
                <set field="statusId" from="contactListParty.statusId"/>
                <entity-update value-field="contactListParty"/>
                <message type="success">You have been unsubscribed from the contact list.</message>
            </then><else>
                <set field="statusId" from="contactListParty?.statusId"/>
                <message>You are already unsubscribed from the contact list.</message>
            </else></if>

<!--            <log level="warn" message="unsubscribe#contactlist context.toString(): ${context.toString()}"/>-->
        </actions>
    </service>

    <service verb="change" noun="UserPassword">
        <in-parameters>
            <parameter name="username" required="true" default="ec.web?.sessionAttributes?.moquiPreAuthcUsername ?: username"/>
            <parameter name="firstName" required="true"/>
            <parameter name="lastName" required="true"/>
            <parameter name="oldPassword" required="true"/>
            <parameter name="newPassword" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="updateSuccessful"/>
            <parameter name="loginSuccess"/>
            <parameter name="passwordIssues"/>
        </out-parameters>
        <actions>
            <service-call name="org.moqui.impl.UserServices.update#Password" in-map="[username:username,
                oldPassword:oldPassword,newPassword:newPassword,newPasswordVerify:newPassword]" out-map="context"/>

            <!-- password change success, login the user -->
            <if condition="updateSuccessful">
                <entity-find-one entity-name="moqui.security.UserAccount" value-field="userAccount">
                    <field-map field-name="username"/>
                    <select-field field-name="userId,partyId"/></entity-find-one>
                <service-call name="update#moqui.security.UserAccount" in-map="[userId:userAccount.userId,userFullName:(firstName?firstName+' ':'')+lastName?:'']"/>
                <service-call name="mantle.party.PartyServices.update#Account" in-map="[userId:userAccount.userId,firstName:firstName,lastName:lastName]"/>
                <set field="loginSuccess" from="ec.user.internalLoginUser(username)"/>

                <!-- Sales Journey Hot Lead user -->
                <service-call name="mantle.party.PartyServices.set#PartyClassification" in-map="[partyId:userAccount.partyId,partyClassificationId:'HotLead']" out-map="context"/>

                <!-- Send welcome email -->
<!--                <service-call name="coarchy.CoarchyServices.send#ContactListEmail" in-map="[-->
<!--                        contactListId:'CoarchyOnboarding',emailTemplateId:'WELCOME',-->
<!--                        partyId:userAccount.partyId,preferredContactMechId:null,toAddresses:username,-->
<!--                        bodyParameters:[title:'Welcome to Coarchy']]" out-map="context"/>-->
            </if>
        </actions>
    </service>

    <service verb="signUp" noun="User">
        <in-parameters>
            <parameter name="emailAddress" required="true"/>
            <parameter name="username" required="true" default="emailAddress"/>
            <parameter name="firstName" required="true"/>
            <parameter name="lastName" required="true"/>
            <parameter name="newPassword" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="partyId"/>
            <parameter name="partyClassificationId"/>
        </out-parameters>
        <actions>
            <service-call name="mantle.party.PartyServices.create#Account" out-map="context"
                    in-map="[emailAddress:emailAddress,firstName:firstName,lastName:lastName,username:emailAddress,newPassword:newPassword,newPasswordVerify:newPassword]"/>
            <service-call name="update#mantle.party.Party" in-map="[partyId:partyId,visibilityEnumId:'PvOrganization']"/>
            <service-call name="create#mantle.party.PartyRole" in-map="[partyId:partyId,roleTypeId:'Customer']"/>
            <service-call name="create#moqui.security.UserGroupMember" in-map="[userGroupId:'COARCHY_USERS', userId:userId, fromDate:ec.user.nowTimestamp]"/>

            <!-- Sales Journey Hot Lead user -->
            <service-call name="mantle.party.PartyServices.set#PartyClassification" in-map="[partyId:partyId,partyClassificationId:'HotLead']" out-map="context"/>

            <!-- Send welcome email -->
<!--            <service-call name="coarchy.CoarchyServices.send#ContactListEmail" in-map="[-->
<!--                        contactListId:'CoarchyOnboarding',emailTemplateId:'WELCOME',-->
<!--                        partyId:partyId,preferredContactMechId:null,toAddresses:username,-->
<!--                        bodyParameters:[title:'Welcome to Coarchy']]" out-map="context"/>-->

        </actions>
    </service>
</services>
